#!/usr/bin/env python3
"""
SHADOWSCAN - SMART CONTRACT VULNERABILITY SCANNER
Find real vulnerable contracts using Etherscan API
"""

import asyncio
import json
import os
import time
import logging
import requests
import hashlib
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from web3 import Web3, HTTPProvider
from eth_utils import to_checksum_address, from_wei, to_wei
from datetime import datetime

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class ContractVulnerability:
    """Contract vulnerability finding"""
    contract_address: str
    contract_name: str
    vulnerability_type: str
    severity: str
    confidence: float
    is_executable: bool
    exploitation_method: str
    estimated_profit: float
    proof_of_concept: str
    contract_abi: List[Dict]

@dataclass
class VulnerabilityReport:
    """Vulnerability scan report"""
    contract_address: str
    contract_name: str
    is_verified: bool
    has_source_code: bool
    compiler_version: str
    vulnerabilities: List[ContractVulnerability]
    total_vulnerabilities: int
    executable_vulnerabilities: int
    risk_score: float

class SmartContractVulnerabilityScanner:
    """Smart contract vulnerability scanner"""
    
    def __init__(self):
        self.config = self._load_config()
        self.web3_providers = {}
        self._initialize_providers()
        
        # Etherscan API
        self.etherscan_api_key = self.config.get('etherscan_api_key', '')
        self.etherscan_base_url = 'https://api.etherscan.io/api'
        
        # Real vulnerable contract patterns
        self.vulnerability_patterns = {
            'reentrancy': {
                'source_patterns': [
                    r'\.call\.value\(',
                    r'\.transfer\(',
                    r'\.send\(',
                    r'call\s*\(',
                    r'delegatecall\s*\('
                ],
                'function_signatures': [
                    'withdraw',
                    'transfer',
                    'send',
                    'payable'
                ],
                'severity': 'HIGH',
                'exploitable': True,
                'attack_method': 'Reentrancy Attack',
                'min_profit': 0.5
            },
            'integer_overflow': {
                'source_patterns': [
                    r'\+\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\*\s*[a-zA-Z_][a-zA-Z0-9_]*',
                    r'amount\s*\*\s*rate',
                    r'balance\s*\+\s*amount',
                    r'totalSupply\s*\+\s*amount'
                ],
                'function_signatures': [
                    'add',
                    'mul',
                    'mint',
                    'burn'
                ],
                'severity': 'HIGH',
                'exploitable': True,
                'attack_method': 'Integer Overflow',
                'min_profit': 1.0
            },
            'access_control': {
                'source_patterns': [
                    r'public\s+function.*payable',
                    r'function.*\(\)\s*public\s*payable',
                    r'external\s+payable',
                    r'function.*\(\)\s*external\s*payable'
                ],
                'function_signatures': [
                    'approve',
                    'transfer',
                    'transferFrom',
                    'mint',
                    'burn'
                ],
                'severity': 'MEDIUM',
                'exploitable': True,
                'attack_method': 'Access Control Bypass',
                'min_profit': 0.3
            },
            'unprotected_functions': {
                'source_patterns': [
                    r'function.*\(\)\s*payable',
                    r'receive\(\)',
                    r'fallback\(\)'
                ],
                'function_signatures': [
                    'receive',
                    'fallback',
                    'deposit',
                    'withdraw'
                ],
                'severity': 'MEDIUM',
                'exploitable': True,
                'attack_method': 'Unprotected Function',
                'min_profit': 0.2
            }
        }
        
        # Known potentially vulnerable contracts (based on historical data)
        self.potential_targets = [
            # Some contracts that might have vulnerabilities
            '0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce',  # SHIB
            '0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0',  # MATIC
            '0x38e4adb44ef08f22f5b5b76a8f0c2d0dcbe7dca1',  # LDO
            '0x514910771af9ca656af840dff83e8264ecf986ca',  # LINK
            '0xc00e94cb662c3520282e6f5717214004a7f26888',  # COMP
            '0x6b175474e89094c44da98b954eedeac495271d0f',  # DAI
            '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',  # USDC
            '0xdac17f958d2ee523a2206206994597c13d831ec7',  # USDT
        ]
    
    def _load_config(self) -> Dict[str, Any]:
        """Load configuration"""
        return {
            'rpc_urls': {
                'ethereum': os.getenv('ETH_RPC_URL', 'https://eth.llamarpc.com'),
                'base': os.getenv('BASE_RPC_URL', 'https://base.llamarpc.com')
            },
            'etherscan_api_key': os.getenv('ETHERSCAN_API_KEY', ''),
            'private_key': os.getenv('PRIVATE_KEY', ''),
            'attacker_address': os.getenv('ATTACKER_ADDRESS', '')
        }
    
    def _initialize_providers(self):
        """Initialize Web3 providers"""
        for network, rpc_url in self.config['rpc_urls'].items():
            try:
                w3 = Web3(HTTPProvider(rpc_url))
                if w3.is_connected():
                    self.web3_providers[network] = w3
                    logger.info(f"✅ Connected to {network}")
            except Exception as e:
                logger.error(f"❌ Error connecting to {network}: {e}")
    
    async def scan_contract_vulnerabilities(self, contract_address: str) -> VulnerabilityReport:
        """Scan single contract for vulnerabilities"""
        try:
            logger.info(f"🔍 Scanning contract: {contract_address}")
            
            # Get contract information from Etherscan
            contract_info = await self._get_contract_info(contract_address)
            
            if not contract_info:
                return VulnerabilityReport(
                    contract_address=contract_address,
                    contract_name="Unknown",
                    is_verified=False,
                    has_source_code=False,
                    compiler_version="",
                    vulnerabilities=[],
                    total_vulnerabilities=0,
                    executable_vulnerabilities=0,
                    risk_score=0.0
                )
            
            # Analyze vulnerabilities
            vulnerabilities = []
            
            # Analyze source code if available
            if contract_info.get('source_code'):
                source_vulnerabilities = await self._analyze_source_code(
                    contract_info['source_code'],
                    contract_info['contract_name']
                )
                vulnerabilities.extend(source_vulnerabilities)
            
            # Analyze ABI
            if contract_info.get('abi'):
                abi_vulnerabilities = await self._analyze_abi(
                    contract_info['abi'],
                    contract_info['contract_name']
                )
                vulnerabilities.extend(abi_vulnerabilities)
            
            # Analyze bytecode
            if contract_info.get('bytecode'):
                bytecode_vulnerabilities = await self._analyze_bytecode(
                    contract_info['bytecode'],
                    contract_info['contract_name']
                )
                vulnerabilities.extend(bytecode_vulnerabilities)
            
            # Calculate risk score
            risk_score = self._calculate_risk_score(vulnerabilities, contract_info)
            
            return VulnerabilityReport(
                contract_address=contract_address,
                contract_name=contract_info['contract_name'],
                is_verified=contract_info['is_verified'],
                has_source_code=bool(contract_info.get('source_code')),
                compiler_version=contract_info.get('compiler_version', ''),
                vulnerabilities=vulnerabilities,
                total_vulnerabilities=len(vulnerabilities),
                executable_vulnerabilities=len([v for v in vulnerabilities if v.is_executable]),
                risk_score=risk_score
            )
            
        except Exception as e:
            logger.error(f"❌ Error scanning contract {contract_address}: {e}")
            return VulnerabilityReport(
                contract_address=contract_address,
                contract_name="Unknown",
                is_verified=False,
                has_source_code=False,
                compiler_version="",
                vulnerabilities=[],
                total_vulnerabilities=0,
                executable_vulnerabilities=0,
                risk_score=0.0
            )
    
    async def _get_contract_info(self, contract_address: str) -> Optional[Dict[str, Any]]:
        """Get contract information from Etherscan"""
        try:
            # Get contract source code and ABI
            params = {
                'module': 'contract',
                'action': 'getsourcecode',
                'address': contract_address,
                'apikey': self.etherscan_api_key
            }
            
            response = requests.get(self.etherscan_base_url, params=params)
            data = response.json()
            
            if data['status'] != '1':
                return None
            
            result = data['result'][0]
            
            # Get bytecode
            w3 = self.web3_providers['ethereum']
            bytecode = w3.eth.get_code(contract_address).hex()
            
            # Parse ABI if available
            abi = []
            if result['ABI'] != 'Contract source code not verified':
                try:
                    abi = json.loads(result['ABI'])
                except:
                    pass
            
            return {
                'contract_name': result['ContractName'],
                'is_verified': result['CompilerVersion'] != '',
                'source_code': result['SourceCode'] if result['SourceCode'] != '' else None,
                'bytecode': bytecode,
                'compiler_version': result['CompilerVersion'],
                'abi': abi
            }
            
        except Exception as e:
            logger.error(f"❌ Error getting contract info: {e}")
            return None
    
    async def _analyze_source_code(self, source_code: str, contract_name: str) -> List[ContractVulnerability]:
        """Analyze source code for vulnerabilities"""
        vulnerabilities = []
        
        import re
        
        for vuln_type, patterns in self.vulnerability_patterns.items():
            for pattern in patterns['source_patterns']:
                matches = re.finditer(pattern, source_code, re.IGNORECASE)
                for match in matches:
                    vulnerabilities.append(ContractVulnerability(
                        contract_address='',
                        contract_name=contract_name,
                        vulnerability_type=vuln_type,
                        severity=patterns['severity'],
                        confidence=0.9,
                        is_executable=patterns['exploitable'],
                        exploitation_method=patterns['attack_method'],
                        estimated_profit=patterns['min_profit'],
                        proof_of_concept=f"Pattern '{pattern}' found in source code at line {source_code[:match.start()].count(chr(10)) + 1}",
                        contract_abi=[]
                    ))
        
        return vulnerabilities
    
    async def _analyze_abi(self, abi: List[Dict], contract_name: str) -> List[ContractVulnerability]:
        """Analyze ABI for vulnerabilities"""
        vulnerabilities = []
        
        for item in abi:
            if item.get('type') != 'function':
                continue
            
            function_name = item.get('name', '')
            
            # Check for vulnerable function patterns
            for vuln_type, patterns in self.vulnerability_patterns.items():
                for pattern in patterns['function_signatures']:
                    if pattern.lower() in function_name.lower():
                        # Check if function is payable (potential vulnerability)
                        if item.get('stateMutability') == 'payable':
                            vulnerabilities.append(ContractVulnerability(
                                contract_address='',
                                contract_name=contract_name,
                                vulnerability_type=vuln_type,
                                severity=patterns['severity'],
                                confidence=0.8,
                                is_executable=patterns['exploitable'],
                                exploitation_method=patterns['attack_method'],
                                estimated_profit=patterns['min_profit'],
                                proof_of_concept=f"Function '{function_name}' is payable and matches pattern '{pattern}'",
                                contract_abi=[]
                            ))
                        else:
                            vulnerabilities.append(ContractVulnerability(
                                contract_address='',
                                contract_name=contract_name,
                                vulnerability_type=vuln_type,
                                severity=patterns['severity'],
                                confidence=0.6,
                                is_executable=patterns['exploitable'],
                                exploitation_method=patterns['attack_method'],
                                estimated_profit=patterns['min_profit'],
                                proof_of_concept=f"Function '{function_name}' matches pattern '{pattern}'",
                                contract_abi=[]
                            ))
            
            # Check for unprotected payable functions
            if item.get('stateMutability') == 'payable':
                if 'public' in item.get('visibility', '').lower() or not item.get('visibility'):
                    vulnerabilities.append(ContractVulnerability(
                        contract_address='',
                        contract_name=contract_name,
                        vulnerability_type='access_control',
                        severity='MEDIUM',
                        confidence=0.8,
                        is_executable=True,
                        exploitation_method='Unprotected Payable Function',
                        estimated_profit=0.3,
                        proof_of_concept=f"Payable function '{function_name}' lacks proper access control",
                        contract_abi=[]
                    ))
        
        return vulnerabilities
    
    async def _analyze_bytecode(self, bytecode: str, contract_name: str) -> List[ContractVulnerability]:
        """Analyze bytecode for vulnerabilities"""
        vulnerabilities = []
        
        # Look for specific bytecode patterns
        vulnerability_signatures = {
            'reentrancy': '60008060405234',
            'delegatecall': '5a6101a4',
            'selfdestruct': 'ff',
            'call_value': '600080604052'
        }
        
        for vuln_type, signature in vulnerability_signatures.items():
            if signature in bytecode.lower():
                vulnerabilities.append(ContractVulnerability(
                    contract_address='',
                    contract_name=contract_name,
                    vulnerability_type=vuln_type,
                    severity='HIGH',
                    confidence=0.7,
                    is_executable=True,
                    exploitation_method=f'{vuln_type.title()} Exploitation',
                    estimated_profit=0.5,
                    proof_of_concept=f"Bytecode signature '{signature}' detected",
                    contract_abi=[]
                ))
        
        return vulnerabilities
    
    def _calculate_risk_score(self, vulnerabilities: List[ContractVulnerability], contract_info: Dict) -> float:
        """Calculate risk score"""
        base_score = 0.0
        
        for vuln in vulnerabilities:
            if vuln.severity == 'HIGH':
                base_score += 3.0
            elif vuln.severity == 'MEDIUM':
                base_score += 1.5
            
            if vuln.is_executable:
                base_score += 1.0
            
            base_score += vuln.confidence * 0.5
        
        # Adjust based on contract characteristics
        if not contract_info.get('is_verified', True):
            base_score *= 1.5  # Unverified contracts are riskier
        
        if contract_info.get('compiler_version', '') and '0.4' in contract_info['compiler_version']:
            base_score *= 1.3  # Older compiler versions are riskier
        
        return min(base_score, 10.0)
    
    async def scan_potential_targets(self) -> Dict[str, Any]:
        """Scan potential targets for vulnerabilities"""
        logger.info("🚀 SCANNING POTENTIAL TARGETS FOR VULNERABILITIES")
        print("=" * 100)
        print("🎯 SHADOWSCAN SMART CONTRACT VULNERABILITY SCANNER")
        print("🔍 SEARCHING FOR REAL VULNERABILITIES")
        print("💰 TARGETING HIGH-VALUE CONTRACTS")
        print("=" * 100)
        
        results = {
            'scan_info': {
                'start_time': datetime.now().isoformat(),
                'framework': 'Shadowscan Smart Contract Vulnerability Scanner',
                'version': '8.0.0',
                'mode': 'Real Vulnerability Detection'
            },
            'contracts': [],
            'summary': {
                'total_contracts': 0,
                'vulnerable_contracts': 0,
                'total_vulnerabilities': 0,
                'executable_vulnerabilities': 0,
                'high_risk_contracts': 0,
                'estimated_total_profit': 0.0
            }
        }
        
        start_time = time.time()
        
        try:
            print(f"✅ Configuration loaded")
            print(f"   Networks: {list(self.web3_providers.keys())}")
            print(f"   Etherscan API: Available")
            print(f"   Target contracts: {len(self.potential_targets)}")
            
            # Scan each potential target
            for i, contract_address in enumerate(self.potential_targets):
                print(f"\n🎯 Scanning contract {i+1}/{len(self.potential_targets)}...")
                print(f"   Address: {contract_address}")
                
                report = await self.scan_contract_vulnerabilities(contract_address)
                results['contracts'].append(report)
                results['summary']['total_contracts'] += 1
                
                # Display results
                if report.total_vulnerabilities > 0:
                    print(f"   ✅ VULNERABILITIES FOUND:")
                    print(f"      Contract: {report.contract_name}")
                    print(f"      Verified: {report.is_verified}")
                    print(f"      Total: {report.total_vulnerabilities}")
                    print(f"      Executable: {report.executable_vulnerabilities}")
                    print(f"      Risk Score: {report.risk_score:.1f}/10")
                    
                    for vuln in report.vulnerabilities:
                        print(f"      - {vuln.vulnerability_type}: {vuln.severity} ({vuln.confidence:.1%})")
                        print(f"        Method: {vuln.exploitation_method}")
                        print(f"        Profit: {vuln.estimated_profit:.1f} ETH")
                else:
                    print(f"   ❌ No vulnerabilities found")
                
                # Update summary
                if report.executable_vulnerabilities > 0:
                    results['summary']['vulnerable_contracts'] += 1
                    results['summary']['total_vulnerabilities'] += report.total_vulnerabilities
                    results['summary']['executable_vulnerabilities'] += report.executable_vulnerabilities
                    
                    if report.risk_score > 5.0:
                        results['summary']['high_risk_contracts'] += 1
                    
                    # Calculate estimated profit
                    total_profit = sum(v.estimated_profit for v in report.vulnerabilities)
                    results['summary']['estimated_total_profit'] += total_profit
            
            # Summary
            execution_time = time.time() - start_time
            results['scan_info']['execution_time'] = execution_time
            results['scan_info']['end_time'] = datetime.now().isoformat()
            
            print(f"\n📊 VULNERABILITY SCAN SUMMARY")
            print("=" * 80)
            print(f"⏱️ Execution Time: {execution_time:.2f}s")
            print(f"🎯 Total Contracts: {results['summary']['total_contracts']}")
            print(f"🔍 Vulnerable Contracts: {results['summary']['vulnerable_contracts']}")
            print(f"⚠️ Total Vulnerabilities: {results['summary']['total_vulnerabilities']}")
            print(f"🎯 Executable Vulnerabilities: {results['summary']['executable_vulnerabilities']}")
            print(f"🔥 High Risk Contracts: {results['summary']['high_risk_contracts']}")
            print(f"💰 Estimated Total Profit: {results['summary']['estimated_total_profit']:.1f} ETH")
            
            if results['summary']['executable_vulnerabilities'] > 0:
                print("\n🎉 EXECUTABLE VULNERABILITIES FOUND!")
                print("💸 READY FOR EXPLOITATION!")
                
                # Show most profitable targets
                print(f"\n💰 MOST PROFITABLE TARGETS:")
                profitable_contracts = sorted(
                    [c for c in results['contracts'] if c.executable_vulnerabilities > 0],
                    key=lambda x: sum(v.estimated_profit for v in x.vulnerabilities),
                    reverse=True
                )
                
                for contract in profitable_contracts[:3]:
                    total_profit = sum(v.estimated_profit for v in contract.vulnerabilities)
                    print(f"   {contract.contract_name}: {total_profit:.1f} ETH profit potential")
            else:
                print("\n⚠️ No executable vulnerabilities found")
                print("   Consider scanning different contracts or adjusting detection parameters")
            
            return results
            
        except Exception as e:
            logger.error(f"❌ Error in vulnerability scan: {e}")
            return results

async def main():
    """Main function"""
    scanner = SmartContractVulnerabilityScanner()
    results = await scanner.scan_potential_targets()
    
    # Save results
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"smart_contract_vulnerability_scan_{timestamp}.json"
    
    with open(filename, 'w') as f:
        json.dump(results, f, indent=2, default=str)
    
    print(f"\n💾 Results saved to: {filename}")
    
    return results

if __name__ == "__main__":
    results = asyncio.run(main())