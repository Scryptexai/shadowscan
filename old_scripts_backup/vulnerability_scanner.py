#!/usr/bin/env python3
"""
Vulnerability Scanner for DEFI/DEX Contracts
Implements detection methods for 30+ vulnerability types based on JSON vulnerability list
"""

import json
import re
import logging
import time
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
from core.database import database

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Comprehensive vulnerability scanner for DEFI/DEX contracts"""

    def __init__(self):
        self.vulnerabilities = self._load_vulnerability_list()
        self.severity_mapping = {
            'CRITICAL': 5,
            'HIGH': 4,
            'MEDIUM': 3,
            'LOW': 2,
            'UNKNOWN': 1
        }

    def _load_vulnerability_list(self) -> Dict[str, Any]:
        """Load vulnerability definitions from JSON"""
        try:
            with open('vulnerability_list.json', 'r') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error loading vulnerability list: {e}")
            return {}

    def _get_vulnerability_config(self, vuln_type: str) -> Dict[str, Any]:
        """Get vulnerability configuration"""
        return self.vulnerabilities.get('vulnerability_categories', {}).get(vuln_type, {})

    def scan_contract_vulnerabilities(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan contract for all vulnerability types"""
        vulnerabilities = []
        contract_address = contract.get('address')
        contract_name = contract.get('name', 'Unknown')
        contract_code = contract.get('source_code', '')
        contract_abi = contract.get('abi', [])

        logger.info(f"Scanning contract: {contract_name} ({contract_address})")

        # Scan for each vulnerability type
        for vuln_type, vuln_config in self.vulnerabilities.get('vulnerability_categories', {}).items():
            try:
                detection_method = getattr(self, f'_detect_{vuln_type.lower().replace("_", "_")}', None)
                if detection_method:
                    results = detection_method(contract)
                    if results:
                        for result in results:
                            vuln_data = self._format_vulnerability(
                                vuln_type, vuln_config, result, contract_address
                            )
                            vulnerabilities.append(vuln_data)

            except Exception as e:
                logger.error(f"Error scanning for {vuln_type}: {e}")

        logger.info(f"Found {len(vulnerabilities)} vulnerabilities in {contract_name}")
        return vulnerabilities

    def _format_vulnerability(self, vuln_type: str, vuln_config: Dict[str, Any],
                            detection_result: Dict[str, Any], contract_address: str) -> Dict[str, Any]:
        """Format vulnerability finding for database storage"""
        return {
            'contract_address': contract_address,
            'vulnerability_type': vuln_type,
            'severity': vuln_config.get('exploit_potential', 'UNKNOWN'),
            'name': vuln_config.get('name', vuln_type),
            'description': vuln_config.get('impact', 'Unknown impact'),
            'detection_signs': vuln_config.get('detection_signs', []),
            'verification_difficulty': vuln_config.get('verification_difficulty', 'Unknown'),
            'mitigation': vuln_config.get('mitigation', 'No mitigation specified'),
            'exploitable': detection_result.get('exploitable', True),
            'confidence': detection_result.get('confidence', 0.5),
            'location': detection_result.get('location', {}),
            'evidence': detection_result.get('evidence', []),
            'recommendation': vuln_config.get('mitigation', ''),
            'discovered_at': datetime.now().isoformat(),
            'scanner_priority': vuln_config.get('scanner_priority', 5)
        }

    # Critical Vulnerability Detection Methods
    def _detect_reentrancy(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect classic reentrancy vulnerabilities"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Pattern: External call followed by state update
        reentrancy_patterns = [
            r'(call|delegatecall|staticcall).*transfer\(',
            r'(call|delegatecall|staticcall).*send\(',
            r'(call|delegatecall|staticcall).*\.value\(',
            r'(call|delegatecall|staticcall).*balance',
            r'(call|delegatecall|staticcall).*\.call{'
        ]

        for pattern in reentrancy_patterns:
            matches = re.finditer(pattern, contract_code)
            for match in matches:
                # Check if state update follows external call (basic heuristic)
                lines_before = contract_code[:match.start()].split('\n')
                lines_after = contract_code[match.end():].split('\n')

                for line in lines_after[:5]:  # Check next 5 lines
                    if any(keyword in line for keyword in ['balances[', 'mapping(', 'this.balance']):
                        vulnerabilities.append({
                            'exploitable': True,
                            'confidence': 0.8,
                            'location': {
                                'line': self._find_line_number(contract_code, match.start()),
                                'pattern': pattern,
                                'snippet': contract_code[match.start():match.end()+100]
                            },
                            'evidence': [
                                'External call detected without mutex pattern',
                                'Potential state update following external call'
                            ]
                        })
                        break

        return vulnerabilities

    def _detect_oracle_manipulation(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect price oracle manipulation vulnerabilities"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Check for oracle usage patterns
        oracle_indicators = [
            'get_price', 'get_underlying_price', 'price_feed', 'price_oracle',
            'chainlink', 'twap', 'pool_amount', 'reserve'
        ]

        suspicious_patterns = [
            (r'block\.timestamp.*[<<=].*[0-9]{2,3}', 'Timestamp manipulation in oracle'),
            (r'(get_price|price_feed)\(\).*\*\s*[0-9]{3,}', 'Direct price multiplication'),
            (r'(get_price|price_feed)\(\).*\/\s*[0-9]{3,}', 'Direct price division'),
            (r'twap.*[0-9]{2,3}', 'Short TWAP window detected')
        ]

        for pattern, description in suspicious_patterns:
            matches = re.finditer(pattern, contract_code)
            for match in matches:
                vulnerabilities.append({
                    'exploitable': True,
                    'confidence': 0.7,
                    'location': {
                        'line': self._find_line_number(contract_code, match.start()),
                        'pattern': pattern,
                        'snippet': contract_code[match.start():match.end()+100]
                    },
                    'evidence': [description]
                })

        return vulnerabilities

    def _detect_flash_loan_manipulation(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect flash loan manipulation vulnerabilities"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Check for flash loan calls
        flash_loan_patterns = [
            r'(flashloan|flash_loan).*call\(',
            r'flash.*loan',
            r'imbalance\.flashLoan',
            r'dydx\.flashLoan',
            r'protocol\.flashLoan'
        ]

        # Check for patterns vulnerable to flash loan attacks
        vulnerable_patterns = [
            (r'(borrow|lend).*\*.*price', 'Borrow/lend operations without slippage protection'),
            (r'arbitrage.*profit', 'Arbitrage operations without checkpoint'),
            (r'liquidate.*\?liquidationBonus', 'Liquidation without proper validation')
        ]

        # First check if contract uses flash loans
        has_flash_loan = any(pattern in contract_code for pattern in flash_loan_patterns)

        if has_flash_loan:
            # Check for vulnerable operations
            for pattern, description in vulnerable_patterns:
                if re.search(pattern, contract_code):
                    vulnerabilities.append({
                        'exploitable': True,
                        'confidence': 0.8,
                        'location': {
                            'line': self._find_line_number(contract_code, match.start()),
                            'pattern': pattern,
                            'snippet': contract_code[match.start():match.end()+100]
                        },
                        'evidence': [description]
                    })

        return vulnerabilities

    def _detect_access_control(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect access control vulnerabilities"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Check for missing access control on sensitive functions
        sensitive_function_patterns = [
            r'function\s+(mint|burn|pause|unpause|set|update|add|remove)',
            r'function\s+(admin|owner|only|require)\s*\('
        ]

        access_control_indicators = [
            'onlyOwner', 'onlyAdmin', 'require(msg.sender',
            'require(tx.origin', 'modifier'
        ]

        # Look for sensitive functions without proper access control
        for pattern in sensitive_function_patterns:
            matches = re.finditer(pattern, contract_code)
            for match in matches:
                # Check if function has proper access control
                function_start = match.start()
                function_end = match.end()

                # Look for access control modifiers in the next 500 characters
                function_context = contract_code[function_start:function_end+500]

                if not any(indicator in function_context for indicator in access_control_indicators):
                    vulnerabilities.append({
                        'exploitable': True,
                        'confidence': 0.9,
                        'location': {
                            'line': self._find_line_number(contract_code, function_start),
                            'pattern': pattern,
                            'snippet': function_context[:200]
                        },
                        'evidence': [
                            'Sensitive function without proper access control',
                            'Potential unauthorized execution risk'
                        ]
                    })

        return vulnerabilities

    def _detect_reentrancy_classic(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect classic reentrancy vulnerabilities"""
        return self._detect_reentrancy(contract)

    def _detect_unchecked_return(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect unchecked return value vulnerabilities"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Pattern: Transfer/call without return value checking
        unchecked_patterns = [
            r'(transfer|send)\([^)]*\)[^;]*;[^!]*\!required!',
            r'(call|delegatecall|staticcall)\([^)]*\)[^;]*;',
            r'address\(\)\.call\('
        ]

        for pattern in unchecked_patterns:
            matches = re.finditer(pattern, contract_code)
            for match in matches:
                # Check if return value is not checked
                if 'require(' not in contract_code[match.start():match.end()+100]:
                    vulnerabilities.append({
                        'exploitable': True,
                        'confidence': 0.7,
                        'location': {
                            'line': self._find_line_number(contract_code, match.start()),
                            'pattern': pattern,
                            'snippet': contract_code[match.start():match.end()+100]
                        },
                        'evidence': [
                            'Unchecked external call return value',
                            'Potential failed transaction without handling'
                        ]
                    })

        return vulnerabilities

    def _detect_delegatecall_untrusted(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect delegatecall to untrusted implementation"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Pattern: Delegatecall with upgradeable pattern
        delegatecall_patterns = [
            r'(delegatecall)\s*\(',
            r'(implementation|proxy|transparent|uups).*upgrade',
            r'(admin|owner).*implementation',
            r'address.*\.delegatecall'
        ]

        for pattern in delegatecall_patterns:
            matches = re.finditer(pattern, contract_code)
            for match in matches:
                # Check if delegation is to user-controlled address
                if 'msg.sender' in contract_code[match.start():match.end()+100] or 'uint256' in contract_code[match.start():match.end()+100]:
                    vulnerabilities.append({
                        'exploitable': True,
                        'confidence': 0.8,
                        'location': {
                            'line': self._find_line_number(contract_code, match.start()),
                            'pattern': pattern,
                            'snippet': contract_code[match.start():match.end()+200]
                        },
                        'evidence': [
                            'Delegatecall to potentially untrusted implementation',
                            'Arbitrary code execution risk'
                        ]
                    })

        return vulnerabilities

    # Additional vulnerability detection methods...
    def _detect_integer_overflow(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect integer overflow/underflow vulnerabilities"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Check for arithmetic operations without safe guards
        arithmetic_patterns = [
            r'(balance\s*[+-].*balance|amount\s*[+-].*amount)',
            r'(uint|int)\d+.*[+-].*\d+',
            r'(uint|int)\d+.*\*\s*\d+',
            r'(uint|int)\d+.*\/\s*\d+'
        ]

        # Check if using Solidity < 0.8 (no built-in overflow protection)
        solidity_version_pattern = r'pragma solidity\s*[>=<]?\s*[\'"]?(0\.[0-7]|1\.[0-7])\.?'
        if re.search(solidity_version_pattern, contract_code):
            for pattern in arithmetic_patterns:
                matches = re.finditer(pattern, contract_code)
                for match in matches:
                    vulnerabilities.append({
                        'exploitable': True,
                        'confidence': 0.6,
                        'location': {
                            'line': self._find_line_number(contract_code, match.start()),
                            'pattern': pattern,
                            'snippet': contract_code[match.start():match.end()+100]
                        },
                        'evidence': [
                            'Arithmetic operations without overflow protection',
                            'Potential integer overflow/underflow'
                        ]
                    })

        return vulnerabilities

    def _detect_approval_misuse(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect approval misuse vulnerabilities"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Check for unlimited approvals
        approval_patterns = [
            r'approve\(.*address.*type\(address\).*uint.*-1',
            r'approve\(.*address.*type\(address\).*uint.*max',
            r'allowance.*\*.*2',
            r'setApprovalForAll.*true'
        ]

        for pattern in approval_patterns:
            matches = re.finditer(pattern, contract_code)
            for match in matches:
                vulnerabilities.append({
                    'exploitable': True,
                    'confidence': 0.8,
                    'location': {
                        'line': self._find_line_number(contract_code, match.start()),
                        'pattern': pattern,
                        'snippet': contract_code[match.start():match.end()+100]
                    },
                    'evidence': [
                        'Unlimited approval detected',
                        'Potential fund drain risk'
                    ]
                })

        return vulnerabilities

    # Add more detection methods as needed...
    def _detect_front_running(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect front-running vulnerabilities"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Check for transaction ordering dependent operations
        front_run_patterns = [
            (r'(swap|exchange|trade).*before.*timestamp', 'Timestamp dependent operation'),
            (r'mempool.*public', 'Public mempool operations'),
            (r'sendValue.*block\.timestamp', 'Value transfer dependent on timestamp')
        ]

        for pattern, description in front_run_patterns:
            matches = re.finditer(pattern, contract_code)
            for match in matches:
                vulnerabilities.append({
                    'exploitable': True,
                    'confidence': 0.7,
                    'location': {
                        'line': self._find_line_number(contract_code, match.start()),
                        'pattern': pattern,
                        'snippet': contract_code[match.start():match.end()+100]
                    },
                    'evidence': [description]
                })

        return vulnerabilities

    def _detect_uninitialized_storage(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Detect uninitialized storage vulnerabilities"""
        vulnerabilities = []
        contract_code = contract.get('source_code', '').lower()

        # Check for uninitialized variables
        uninitialized_patterns = [
            r'uint.*=.*0;',
            r'bool.*=.*false;',
            r'address.*=.*address\(0\);',
            r'constructor.*\{[^}]*\}'
        ]

        # Check if constructor properly initializes state variables
        constructor_pattern = r'constructor\s*\([^)]*\)\s*\{([^}]*)\}'
        constructor_match = re.search(constructor_pattern, contract_code)

        if constructor_match:
            constructor_body = constructor_match.group(1)
            # Check if all state variables are initialized
            if not any(pattern in constructor_body for pattern in uninitialized_patterns[:3]):
                vulnerabilities.append({
                    'exploitable': True,
                    'confidence': 0.6,
                    'location': {
                        'line': self._find_line_number(contract_code, constructor_match.start()),
                        'pattern': 'constructor',
                        'snippet': constructor_body
                    },
                    'evidence': [
                        'Potentially uninitialized state variables',
                        'Proxy pattern initialization risk'
                    ]
                })

        return vulnerabilities

    def _find_line_number(self, text: str, position: int) -> int:
        """Find line number for a given position in text"""
        return text[:position].count('\n') + 1

    def scan_all_contracts(self, chain_name: str) -> List[Dict[str, Any]]:
        """Scan all contracts for a specific chain"""
        vulnerabilities = []

        try:
            # Get all contracts for the chain
            contracts = database.get_contracts(chain_name)

            logger.info(f"Scanning {len(contracts)} contracts in {chain_name}")

            for contract in contracts:
                contract_vulns = self.scan_contract_vulnerabilities(contract)
                vulnerabilities.extend(contract_vulns)

                # Save vulnerabilities to database
                for vuln in contract_vulns:
                    database.add_vulnerability(vuln)

                # Rate limiting
                time.sleep(0.1)

        except Exception as e:
            logger.error(f"Error scanning contracts for {chain_name}: {e}")

        return vulnerabilities

    def get_vulnerability_summary(self) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        return database.get_vulnerability_summary()

def main():
    """Main execution function"""
    scanner = VulnerabilityScanner()

    # Scan all contracts for all chains
    all_vulnerabilities = []

    try:
        with open('defi_target_list.json', 'r') as f:
            data = json.load(f)
            chains = list(data.get('defi_targets', {}).keys())

        for chain in chains:
            logger.info(f"Scanning chain: {chain}")
            vulnerabilities = scanner.scan_all_contracts(chain)
            all_vulnerabilities.extend(vulnerabilities)

            # Print summary
            vuln_count = len(vulnerabilities)
            logger.info(f"Found {vuln_count} vulnerabilities in {chain}")

        # Print final summary
        print("\n📊 Vulnerability Scan Summary:")
        print("=" * 50)

        summary = scanner.get_vulnerability_summary()
        print(f"Total Vulnerabilities: {summary['total']}")
        print(f"By Severity: {summary['by_severity']}")
        print(f"Exploitable: {summary['by_exploitability']}")

    except Exception as e:
        logger.error(f"Error in main scan: {e}")

if __name__ == "__main__":
    main()