"""
Unit tests for vulnerability detectors.
Tests detection logic for all 20 vulnerability types.
"""

import pytest
import tempfile
import shutil
from unittest.mock import Mock, AsyncMock, patch
from web3 import Web3

from shadowscan.adapters.evm.provider import EVMProvider
from shadowscan.detectors.evm.vulnerability_detectors import (
    BaseVulnerabilityDetector, VulnerabilityType, ReentrancyDetector, FlashloanDetector,
    AccessControlDetector, IntegerOverflowDetector
)
from shadowscan.detectors.evm.additional_detectors import (
    UncheckedCallsDetector, FrontRunningDetector, TimeManipulationDetector,
    TokenApprovalDetector, DelegateCallMisuseDetector, SelfdestructMisuseDetector
)
from shadowscan.detectors.evm.specialized_detectors import (
    ProxyMisuseDetector, UpgradeMechanismDetector, MulticallExploitDetector,
    SignatureReplayDetector, StorageCollisionDetector, GasLimitationDetector
)
from shadowscan.detectors.evm.defi_detectors import (
    FeeManipulationDetector, SlippageProtectionDetector, PauseMechanismDetector
)
from shadowscan.models.findings import SeverityLevel


class TestVulnerabilityDetectors:
    """Test suite for vulnerability detectors."""
    
    def setup_method(self):
        """Set up test environment."""
        self.provider = Mock(spec=EVMProvider)
        self.test_contract = "0x1234567890123456789012345678901234567890"
        
        # Mock contract info
        self.mock_contract_info = Mock()
        self.mock_contract_info.source_code = """
        contract TestContract {
            uint256 public balance;
            address public owner;
            
            constructor() {
                owner = msg.sender;
            }
            
            function vulnerableReentrancy() public {
                (bool success, ) = msg.sender.call{value: balance}("");
                balance = 0;
            }
            
            function withdraw() public {
                require(msg.sender == owner, "Not owner");
                msg.sender.transfer(balance);
            }
            
            function unsafeApprove(address spender, uint256 amount) public {
                // Unsafe approve pattern
                approve(spender, amount);
            }
            
            function calculateFee(uint256 amount) public pure returns (uint256) {
                return amount * 2 / 100; // 2% fee
            }
        }
        """
        
        self.provider.get_contract_info = AsyncMock(return_value=self.mock_contract_info)
    
    def test_base_detector_initialization(self):
        """Test base detector initialization."""
        detector = BaseVulnerabilityDetector(self.provider)
        assert detector.provider == self.provider
    
    def test_vulnerability_type_enum(self):
        """Test vulnerability type enumeration."""
        assert VulnerabilityType.REENTRANCY.value == "reentrancy"
        assert VulnerabilityType.FLASHLOAN.value == "flashloan"
        assert VulnerabilityType.ACCESS_CONTROL.value == "access_control"
        assert VulnerabilityType.INTEGER_OVERFLOW.value == "integer_overflow"
    
    def test_base_detector_impact_calculation(self):
        """Test impact score calculation."""
        detector = BaseVulnerabilityDetector(self.provider)
        
        reentrancy_impact = detector._calculate_impact(VulnerabilityType.REENTRANCY)
        assert reentrancy_impact == 0.9
        
        access_control_impact = detector._calculate_impact(VulnerabilityType.ACCESS_CONTROL)
        assert access_control_impact == 0.8
        
        unknown_impact = detector._calculate_impact("unknown_type")
        assert unknown_impact == 0.5


class TestReentrancyDetector:
    """Test reentrancy vulnerability detector."""
    
    def setup_method(self):
        """Set up test environment."""
        self.provider = Mock(spec=EVMProvider)
        self.detector = ReentrancyDetector(self.provider)
        self.test_contract = "0x1234567890123456789012345678901234567890"
    
    @pytest.mark.asyncio
    async def test_reentrancy_detection(self):
        """Test reentrancy vulnerability detection."""
        # Mock contract with reentrancy vulnerability
        mock_contract_info = Mock()
        mock_contract_info.source_code = """
        contract VulnerableContract {
            mapping(address => uint256) public balances;
            
            function withdraw() public {
                uint256 amount = balances[msg.sender];
                (bool success, ) = msg.sender.call{value: amount}("");
                balances[msg.sender] = 0;
            }
        }
        """
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        findings = await self.detector.screen(self.test_contract)
        
        assert len(findings) > 0
        assert any(hasattr(f, 'vulnerability_type') and 
                  f.vulnerability_type == VulnerabilityType.REENTRANCY for f in findings)
    
    @pytest.mark.asyncio
    async def test_no_reentrancy_safe_contract(self):
        """Test safe contract without reentrancy."""
        mock_contract_info = Mock()
        mock_contract_info.source_code = """
        contract SafeContract {
            mapping(address => uint256) public balances;
            
            function withdraw() public {
                uint256 amount = balances[msg.sender];
                balances[msg.sender] = 0;
                (bool success, ) = msg.sender.call{value: amount}("");
            }
        }
        """
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        findings = await self.detector.screen(self.test_contract)
        
        # Should find fewer or no reentrancy vulnerabilities
        assert len(findings) == 0 or all(
            not hasattr(f, 'vulnerability_type') or 
            f.vulnerability_type != VulnerabilityType.REENTRANCY 
            for f in findings
        )
    
    def test_find_call_before_update(self):
        """Test detection of call before update pattern."""
        source_code = """
        function vulnerable() public {
            (bool success, ) = msg.sender.call{value: amount}("");
            balance = 0;
        }
        """
        
        result = self.detector._find_call_before_update(source_code)
        
        assert result is not None
        assert 'functions' in result
        assert len(result['functions']) > 0
    
    def test_check_missing_reentrancy_guard(self):
        """Test detection of missing reentrancy guard."""
        source_code = """
        function withoutGuard() public {
            (bool success, ) = msg.sender.call{value: amount}("");
        }
        """
        
        result = self.detector._check_missing_reentrancy_guard(source_code)
        
        assert result is not None
        assert 'functions' in result
        assert len(result['functions']) > 0


class TestAccessControlDetector:
    """Test access control vulnerability detector."""
    
    def setup_method(self):
        """Set up test environment."""
        self.provider = Mock(spec=EVMProvider)
        self.detector = AccessControlDetector(self.provider)
        self.test_contract = "0x1234567890123456789012345678901234567890"
    
    @pytest.mark.asyncio
    async def test_missing_owner_controls(self):
        """Test detection of missing owner controls."""
        mock_contract_info = Mock()
        mock_contract_info.source_code = """
        contract PublicWithdraw {
            function withdraw() public {
                msg.sender.transfer(address(this).balance);
            }
        }
        """
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        findings = await self.detector.screen(self.test_contract)
        
        assert len(findings) > 0
        assert any(hasattr(f, 'vulnerability_type') and 
                  f.vulnerability_type == VulnerabilityType.ACCESS_CONTROL for f in findings)
    
    def test_check_missing_owner_controls(self):
        """Test checking for missing owner controls."""
        source_code = """
        function withdraw() public {
            msg.sender.transfer(address(this).balance);
        }
        """
        
        result = self.detector._check_missing_owner_controls(source_code)
        
        assert result is not None
        assert 'functions' in result
        assert 'withdraw' in result['functions']
    
    def test_check_uninitialized_ownership(self):
        """Test checking for uninitialized ownership."""
        source_code = """
        contract Test {
            address public owner;
            constructor() {}
        }
        """
        
        result = self.detector._check_uninitialized_ownership(source_code)
        
        assert result is not None
        assert 'missing' in result


class TestIntegerOverflowDetector:
    """Test integer overflow vulnerability detector."""
    
    def setup_method(self):
        """Set up test environment."""
        self.provider = Mock(spec=EVMProvider)
        self.detector = IntegerOverflowDetector(self.provider)
        self.test_contract = "0x1234567890123456789012345678901234567890"
    
    @pytest.mark.asyncio
    async def test_unsafe_arithmetic_detection(self):
        """Test unsafe arithmetic operations detection."""
        mock_contract_info = Mock()
        mock_contract_info.source_code = """
        contract UnsafeArithmetic {
            function add(uint256 a, uint256 b) public pure returns (uint256) {
                return a + b; // Potential overflow
            }
        }
        """
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        findings = await self.detector.screen(self.test_contract)
        
        assert len(findings) > 0
        assert any(hasattr(f, 'vulnerability_type') and 
                  f.vulnerability_type == VulnerabilityType.INTEGER_OVERFLOW for f in findings)
    
    def test_check_unsafe_arithmetic(self):
        """Test checking for unsafe arithmetic."""
        source_code = """
        function unsafe() public pure returns (uint256) {
            return a + b * c;
        }
        """
        
        result = self.detector._check_unsafe_arithmetic(source_code)
        
        assert result is not None
        assert 'functions' in result
        assert 'operations' in result


class TestTokenApprovalDetector:
    """Test token approval vulnerability detector."""
    
    def setup_method(self):
        """Set up test environment."""
        self.provider = Mock(spec=EVMProvider)
        self.detector = TokenApprovalDetector(self.provider)
        self.test_contract = "0x1234567890123456789012345678901234567890"
    
    @pytest.mark.asyncio
    async def test_unsafe_approve_pattern(self):
        """Test unsafe approve pattern detection."""
        mock_contract_info = Mock()
        mock_contract_info.source_code = """
        contract UnsafeApprove {
            function setAllowance(address spender, uint256 amount) public {
                IToken(token).approve(spender, amount); // Unsafe pattern
            }
        }
        """
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        findings = await self.detector.screen(self.test_contract)
        
        assert len(findings) > 0
        assert any(hasattr(f, 'vulnerability_type') and 
                  f.vulnerability_type == VulnerabilityType.TOKEN_APPROVAL for f in findings)
    
    def test_check_unsafe_approve_pattern(self):
        """Test checking for unsafe approve pattern."""
        source_code = """
        function approveAmount(address spender, uint256 amount) public {
            approve(spender, amount);
        }
        """
        
        result = self.detector._check_unsafe_approve_pattern(source_code)
        
        assert result is not None
        assert 'functions' in result
        assert 'operations' in result


class TestDelegateCallMisuseDetector:
    """Test delegatecall misuse vulnerability detector."""
    
    def setup_method(self):
        """Set up test environment."""
        self.provider = Mock(spec=EVMProvider)
        self.detector = DelegateCallMisuseDetector(self.provider)
        self.test_contract = "0x1234567890123456789012345678901234567890"
    
    @pytest.mark.asyncio
    async def test_user_controlled_delegatecall(self):
        """Test user-controlled delegatecall detection."""
        mock_contract_info = Mock()
        mock_contract_info.source_code = """
        contract VulnerableDelegate {
            function execute(address target) public {
                target.delegatecall(abi.encodeWithSignature("exploit()"));
            }
        }
        """
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        findings = await self.detector.screen(self.test_contract)
        
        assert len(findings) > 0
        assert any(hasattr(f, 'vulnerability_type') and 
                  f.vulnerability_type == VulnerabilityType.DELEGATECALL_MISUSE for f in findings)
    
    def test_check_user_controlled_delegatecall(self):
        """Test checking for user-controlled delegatecall."""
        source_code = """
        function execute(address _target) public {
            _target.delegatecall("");
        }
        """
        
        result = self.detector._check_user_controlled_delegatecall(source_code)
        
        assert result is not None
        assert 'functions' in result
        assert 'operations' in result


class TestGasLimitationDetector:
    """Test gas limitation vulnerability detector."""
    
    def setup_method(self):
        """Set up test environment."""
        self.provider = Mock(spec=EVMProvider)
        self.detector = GasLimitationDetector(self.provider)
        self.test_contract = "0x1234567890123456789012345678901234567890"
    
    @pytest.mark.asyncio
    async def test_unbounded_loops_detection(self):
        """Test unbounded loops detection."""
        mock_contract_info = Mock()
        mock_contract_info.source_code = """
        contract UnboundedLoops {
            function processArray(uint[] memory data) public {
                for (uint i = 0; i < data.length; i++) {
                    // Process each element
                }
            }
        }
        """
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        findings = await self.detector.screen(self.test_contract)
        
        assert len(findings) > 0
        assert any(hasattr(f, 'vulnerability_type') and 
                  f.vulnerability_type == VulnerabilityType.GAS_LIMITATION for f in findings)
    
    def test_check_unbounded_loops(self):
        """Test checking for unbounded loops."""
        source_code = """
        function loop() public {
            for (uint i = 0; i < items.length; i++) {
                // Do something
            }
        }
        """
        
        result = self.detector._check_unbounded_loops(source_code)
        
        assert result is not None
        assert 'functions' in result
        assert 'patterns' in result


class TestComprehensiveScanner:
    """Test comprehensive vulnerability scanner."""
    
    def setup_method(self):
        """Set up test environment."""
        self.provider = Mock(spec=EVMProvider)
        from shadowscan.detectors.evm.defi_detectors import ComprehensiveVulnerabilityScanner
        self.scanner = ComprehensiveVulnerabilityScanner(self.provider)
        self.test_contract = "0x1234567890123456789012345678901234567890"
    
    def test_scanner_initialization(self):
        """Test comprehensive scanner initialization."""
        assert self.scanner.provider == self.provider
        assert len(self.scanner.detectors) >= 20  # Should have 20+ detectors
    
    @pytest.mark.asyncio
    async def test_comprehensive_scan(self):
        """Test comprehensive vulnerability scan."""
        # Mock contract with multiple vulnerabilities
        mock_contract_info = Mock()
        mock_contract_info.source_code = """
        contract MultiVulnerable {
            mapping(address => uint256) public balances;
            address public owner;
            
            function withdraw() public {
                (bool success, ) = msg.sender.call{value: balances[msg.sender]}("");
                balances[msg.sender] = 0;
            }
            
            function unsafeAdd(uint256 a, uint256 b) public pure returns (uint256) {
                return a + b;
            }
            
            function execute(address target) public {
                target.delegatecall("");
            }
        }
        """
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        results = await self.scanner.comprehensive_scan(self.test_contract)
        
        assert 'total_findings' in results
        assert 'severity_distribution' in results
        assert 'detector_results' in results
        assert 'scan_metadata' in results
        
        # Should find multiple vulnerabilities
        assert results['total_findings'] > 0
        assert results['scan_metadata']['detectors_used'] >= 20


class TestEdgeCases:
    """Test edge cases and error handling."""
    
    def setup_method(self):
        """Set up test environment."""
        self.provider = Mock(spec=EVMProvider)
        self.detector = ReentrancyDetector(self.provider)
        self.test_contract = "0x1234567890123456789012345678901234567890"
    
    @pytest.mark.asyncio
    async def test_no_source_code(self):
        """Test handling when no source code is available."""
        mock_contract_info = Mock()
        mock_contract_info.source_code = None
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        findings = await self.detector.screen(self.test_contract)
        
        assert len(findings) == 0  # Should handle gracefully
    
    @pytest.mark.asyncio
    async def test_empty_source_code(self):
        """Test handling of empty source code."""
        mock_contract_info = Mock()
        mock_contract_info.source_code = ""
        
        self.provider.get_contract_info = AsyncMock(return_value=mock_contract_info)
        
        findings = await self.detector.screen(self.test_contract)
        
        assert len(findings) == 0  # Should handle gracefully
    
    @pytest.mark.asyncio
    async def test_provider_error(self):
        """Test handling of provider errors."""
        self.provider.get_contract_info = AsyncMock(side_effect=Exception("Provider error"))
        
        findings = await self.detector.screen(self.test_contract)
        
        assert len(findings) == 0  # Should handle gracefully
    
    def test_pattern_matching_edge_cases(self):
        """Test pattern matching edge cases."""
        detector = ReentrancyDetector(self.provider)
        
        # Test empty source code
        result = detector._find_call_before_update("")
        assert result is None
        
        # Test source code without functions
        result = detector._find_call_before_update("contract Empty {}")
        assert result is None
        
        # Test malformed source code
        result = detector._find_call_before_update("function broken {")
        assert result is None