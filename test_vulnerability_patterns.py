#!/usr/bin/env python3
"""
Test Vulnerability Pattern Detection
Tests the scanner with realistic vulnerability patterns
"""

import json
from vulnerability_scanner import VulnerabilityScanner

def test_vulnerability_patterns():
    """Test scanner with contracts containing known vulnerability patterns"""
    print("üß™ Testing Vulnerability Pattern Detection")
    print("="*60)

    scanner = VulnerabilityScanner()

    # Test contracts with known vulnerability patterns
    test_contracts = [
        {
            'name': 'Vulnerable Lending Contract',
            'address': '0x1234567890123456789012345678901234567890',
            'source_code': '''
// Contract with reentrancy vulnerability
contract VulnerableLending {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public allowances;

    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount; // State change before external call
        payable(msg.sender).transfer(amount); // REENTRANCY VULNERABILITY
    }

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function getPrice() public view returns (uint256) {
        // ORACLE MANIPULATION VULNERABILITY
        return block.timestamp * 1e18; // Uses timestamp for price
    }
}''',
            'category': 'LENDING',
            'chain_id': 1,
            'chain_name': 'ethereum_mainnet'
        },
        {
            'name': 'Insecure DEX',
            'address': '0x2345678901234567890123456789012345678901',
            'source_code': '''
// Contract with multiple vulnerabilities
contract InsecureDEX {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    // ACCESS CONTROL VULNERABILITY
    function setEmergency(bool emergency) public {
        require(msg.sender == owner, "Not owner");
        isEmergency = emergency;
    }

    function swap(address tokenIn, uint256 amountIn, address tokenOut, uint256 amountOut) public {
        require(!isEmergency, "Emergency mode");

        // FRONT RUNNING VULNERABILITY
        uint256 price = getPrice(); // Price can be manipulated
        if (amountIn * price < amountOut) {
            // Swap logic without slippage protection
            balances[tokenIn][msg.sender] -= amountIn;
            balances[tokenOut][msg.sender] += amountOut;
        }
    }

    function approve(address spender, uint256 amount) public {
        // APPROVAL MISUSE VULNERABILITY
        allowances[msg.sender][spender] = amount; // No limit check
    }

    function getPrice() public view returns (uint256) {
        return block.timestamp * 1e18; // TIME DEPENDENCE VULNERABILITY
    }
}''',
            'category': 'DEX',
            'chain_id': 137,
            'chain_name': 'polygon_mainnet'
        },
        {
            'name': 'Flash Loan Arbitrage',
            'address': '0x3456789012345678901234567890123456789012',
            'source_code': '''
// Contract with flash loan vulnerability
contract FlashLoanArbitrage {
    mapping(address => uint256) public prices;

    // FLASH LOAN MANIPULATION VULNERABILITY
    function executeFlashLoan(address flashLoanProvider, uint256 amount) public {
        uint256 currentPrice = prices[token];
        uint256 expectedReturn = amount * currentPrice;

        // Execute arbitrage without checkpoint
        uint256 actualReturn = executeArbitrage(flashLoanProvider, amount);

        if (actualReturn > expectedReturn) {
            // Profit from manipulation
            uint256 profit = actualReturn - expectedReturn;
            payable(msg.sender).transfer(profit);
        }
    }

    function executeArbitrage(address provider, uint256 amount) internal returns (uint256) {
        // Arbitrage logic without slippage protection
        return amount * 1e18; // Simplified for test
    }

    // UNCHECKED RETURN VULNERABILITY
    function transferToUser(address user, uint256 amount) public {
        user.call{value: amount}(""); // No return value check
    }
}''',
            'category': 'YIELD_OPTIMIZER',
            'chain_id': 42161,
            'chain_name': 'arbitrum_one'
        },
        {
            'name': 'Proxy Upgrade Contract',
            'address': '0x456789012345678901234567890123456787890',
            'source_code': '''
// Proxy with upgrade vulnerability
contract Proxy {
    address public implementation;
    address public admin;

    constructor(address _implementation) {
        implementation = _implementation;
        admin = msg.sender;
    }

    // DELEGATECALL UNTRUSTED VULNERABILITY
    function upgradeTo(address newImplementation) public {
        require(msg.sender == admin, "Not admin");
        implementation = newImplementation;
    }

    function delegateCall(address to, bytes memory data) public returns (bytes memory) {
        require(to != address(0), "Invalid address");
        return delegatecall(to, data); // Arbitrary code execution
    }

    // UNINITIALIZED STORAGE VULNERABILITY
    function initialize() public {
        if (initialized) revert();
        initialized = true;
    }
}''',
            'category': 'UNKNOWN',
            'chain_id': 10,
            'chain_name': 'optimism'
        }
    ]

    total_vulnerabilities = 0

    for i, contract in enumerate(test_contracts):
        print(f"\nüéØ Testing Contract {i+1}/{len(test_contracts)}: {contract['name']}")
        print(f"   Address: {contract['address']}")
        print(f"   Category: {contract['category']}")
        print(f"   Chain: {contract['chain_name']}")

        try:
            vulnerabilities = scanner.scan_contract_vulnerabilities(contract)

            if vulnerabilities:
                print(f"   ‚ö†Ô∏è  Found {len(vulnerabilities)} vulnerabilities:")
                for vuln in vulnerabilities:
                    severity = vuln.get('severity', 'UNKNOWN')
                    vuln_type = vuln.get('vulnerability_type', 'Unknown')
                    confidence = vuln.get('confidence', 0)
                    location = vuln.get('location', {})
                    line = location.get('line', 'Unknown')
                    snippet = location.get('snippet', '')[:50] + '...'

                    print(f"      ‚Ä¢ {severity}: {vuln_type}")
                    print(f"        Confidence: {confidence:.2f}, Line: {line}")
                    print(f"        Evidence: {', '.join(vuln.get('evidence', []))}")
                    print(f"        Snippet: {snippet}")

                    total_vulnerabilities += 1
            else:
                print(f"   ‚úÖ No vulnerabilities found")

        except Exception as e:
            print(f"   ‚ùå Error scanning: {e}")

    print(f"\nüìä Pattern Detection Summary")
    print("="*60)
    print(f"Total Contracts Tested: {len(test_contracts)}")
    print(f"Total Vulnerabilities Found: {total_vulnerabilities}")
    print(f"Detection Rate: {total_vulnerabilities / len(test_contracts):.2f} vulnerabilities per contract")

    # Test specific vulnerability types
    print(f"\nüîç Vulnerability Types Detected:")
    vuln_types = {}
    for contract in test_contracts:
        try:
            vulnerabilities = scanner.scan_contract_vulnerabilities(contract)
            for vuln in vulnerabilities:
                vuln_type = vuln.get('vulnerability_type', 'Unknown')
                vuln_types[vuln_type] = vuln_types.get(vuln_type, 0) + 1
        except Exception:
            pass

    for vuln_type, count in vuln_types.items():
        print(f"   ‚Ä¢ {vuln_type}: {count} instances")

    print("\n‚úÖ Pattern detection test completed successfully")

if __name__ == "__main__":
    test_vulnerability_patterns()