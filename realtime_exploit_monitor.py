#!/usr/bin/env python3
"""
SHADOWSCAN - REAL-TIME EXPLOIT MONITORING
Real-time exploit monitoring and alerting system
"""

import asyncio
import json
import os
import time
import logging
import smtplib
from email.mime.text import MIMEText
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, asdict
from web3 import Web3, HTTPProvider
from eth_utils import to_checksum_address, from_wei
from datetime import datetime, timedelta
import aiohttp
import websockets
import redis
import threading
from queue import Queue, Empty

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class ExploitAlert:
    """Real-time exploit alert"""
    alert_id: str
    timestamp: str
    severity: str
    vulnerability_type: str
    target_address: str
    target_name: str
    network: str
    exploit_detected: bool
    exploit_method: str
    estimated_profit: float
    confidence: float
    risk_score: float
    action_required: bool
    alert_message: str
    transaction_hash: str
    block_number: int
    gas_used: int
    gas_cost: float
    attacker_address: str
    victim_address: str
    status: str
    response_time: float
    metadata: Dict[str, Any]

class RealTimeExploitMonitor:
    """Real-time exploit monitoring and alerting system"""
    
    def __init__(self):
        self.config = self._load_config()
        self.web3_providers = {}
        self._initialize_providers()
        
        # Alert system
        self.alert_queue = Queue()
        self.alert_history = []
        self.alert_subscribers = []
        
        # Monitoring parameters
        self.monitoring_active = False
        self.last_checked_block = {}
        self.exploit_signatures = self._load_exploit_signatures()
        
        # Real-time monitoring
        self.monitoring_tasks = []
        self.alert_handlers = []
        
        # Statistics
        self.monitoring_stats = {
            'total_alerts': 0,
            'critical_alerts': 0,
            'exploits_detected': 0,
            'false_positives': 0,
            'average_response_time': 0.0,
            'most_active_network': '',
            'most_common_vulnerability': ''
        }
    
    def _load_config(self) -> Dict[str, Any]:
        """Load configuration"""
        return {
            'rpc_urls': {
                'ethereum': os.getenv('ETH_RPC_URL', 'https://eth.llamarpc.com'),
                'base': os.getenv('BASE_RPC_URL', 'https://base.llamarpc.com'),
                'arbitrum': os.getenv('ARBITRUM_RPC_URL', 'https://arbitrum.llamarpc.com'),
                'polygon': os.getenv('POLYGON_RPC_URL', 'https://polygon.llamarpc.com')
            },
            'alert_config': {
                'email_enabled': os.getenv('EMAIL_ENABLED', 'false').lower() == 'true',
                'email_host': os.getenv('EMAIL_HOST', 'smtp.gmail.com'),
                'email_port': int(os.getenv('EMAIL_PORT', '587')),
                'email_user': os.getenv('EMAIL_USER', ''),
                'email_password': os.getenv('EMAIL_PASSWORD', ''),
                'alert_recipients': os.getenv('ALERT_RECIPIENTS', '').split(','),
                'webhook_url': os.getenv('WEBHOOK_URL', ''),
                'discord_webhook': os.getenv('DISCORD_WEBHOOK', ''),
                'telegram_bot_token': os.getenv('TELEGRAM_BOT_TOKEN', ''),
                'telegram_chat_id': os.getenv('TELEGRAM_CHAT_ID', '')
            },
            'monitoring_config': {
                'check_interval': int(os.getenv('CHECK_INTERVAL', '5')),
                'block_lookback': int(os.getenv('BLOCK_LOOKBACK', '10')),
                'alert_threshold': float(os.getenv('ALERT_THRESHOLD', '0.7')),
                'critical_threshold': float(os.getenv('CRITICAL_THRESHOLD', '0.9')),
                'max_alerts_per_minute': int(os.getenv('MAX_ALERTS_PER_MINUTE', '10')),
                'response_timeout': int(os.getenv('RESPONSE_TIMEOUT', '30'))
            },
            'redis_config': {
                'host': os.getenv('REDIS_HOST', 'localhost'),
                'port': int(os.getenv('REDIS_PORT', '6379')),
                'db': int(os.getenv('REDIS_DB', '0')),
                'password': os.getenv('REDIS_PASSWORD', '')
            }
        }
    
    def _initialize_providers(self):
        """Initialize Web3 providers"""
        for network, rpc_url in self.config['rpc_urls'].items():
            try:
                w3 = Web3(HTTPProvider(rpc_url))
                if w3.is_connected():
                    self.web3_providers[network] = w3
                    self.last_checked_block[network] = w3.eth.block_number
                    logger.info(f"‚úÖ Connected to {network}")
            except Exception as e:
                logger.error(f"‚ùå Error connecting to {network}: {e}")
    
    def _load_exploit_signatures(self) -> Dict[str, Any]:
        """Load exploit signatures for detection"""
        return {
            'reentrancy_attack': {
                'patterns': [
                    '0x2e1a7d4d',  # withdraw
                    '0xd0e30db0',  # deposit
                    '0x39509351'   # fallback
                ],
                'indicators': [
                    'call.value',
                    'transfer',
                    'send',
                    'payable'
                ],
                'severity': 'critical',
                'detection_method': 'bytecode_pattern',
                'response_priority': 'immediate'
            },
            'flash_loan_attack': {
                'patterns': [
                    '0x2f2ff15d',  # flashLoan
                    '0x5f65e9a7',  # executeOperation
                    '0x39509351'   # fallback
                ],
                'indicators': [
                    'borrow',
                    'repay',
                    'fee',
                    'premium'
                ],
                'severity': 'critical',
                'detection_method': 'transaction_pattern',
                'response_priority': 'immediate'
            },
            'approval_hijack': {
                'patterns': [
                    '0x095ea7b3',  # approve
                    '0x23b872dd',  # transferFrom
                    '0xdd62ed3e'   # allowance
                ],
                'indicators': [
                    'unlimited',
                    'max_uint256',
                    'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
                ],
                'severity': 'high',
                'detection_method': 'transaction_pattern',
                'response_priority': 'high'
            },
            'price_manipulation': {
                'patterns': [
                    '0x8803dbee',  # swapExactTokensForTokens
                    '0x38ed1739',  # swapExactETHForTokens
                    '0x7ff36ab5'   # swapExactTokensForETH
                ],
                'indicators': [
                    'large_value',
                    'multiple_swaps',
                    'price_impact'
                ],
                'severity': 'high',
                'detection_method': 'behavioral_pattern',
                'response_priority': 'high'
            },
            'access_control_bypass': {
                'patterns': [
                    '0x0894525e',  # transferOwnership
                    '0x4e71d92d',  # renounceOwnership
                    '0x5c19a95c'   # onlyOwner
                ],
                'indicators': [
                    'unauthorized_call',
                    'privilege_escalation',
                    'admin_functions'
                ],
                'severity': 'critical',
                'detection_method': 'transaction_pattern',
                'response_priority': 'immediate'
            }
        }
    
    async def monitor_network(self, network: str):
        """Monitor a specific network for exploits"""
        if network not in self.web3_providers:
            return
        
        w3 = self.web3_providers[network]
        
        try:
            current_block = w3.eth.block_number
            last_block = self.last_checked_block.get(network, current_block - 1)
            
            # Check new blocks
            for block_num in range(last_block + 1, current_block + 1):
                try:
                    await self._analyze_block(block_num, w3, network)
                except Exception as e:
                    logger.error(f"‚ùå Error analyzing block {block_num} on {network}: {e}")
                    continue
            
            self.last_checked_block[network] = current_block
            
        except Exception as e:
            logger.error(f"‚ùå Error monitoring {network}: {e}")
    
    async def _analyze_block(self, block_num: int, w3: Web3, network: str):
        """Analyze a block for potential exploits"""
        try:
            block = w3.eth.get_block(block_num, full_transactions=True)
            
            if not block or not block.transactions:
                return
            
            # Analyze each transaction
            for tx in block.transactions:
                await self._analyze_transaction(tx, w3, network, block_num)
        
        except Exception as e:
            logger.error(f"‚ùå Error analyzing block {block_num}: {e}")
    
    async def _analyze_transaction(self, tx, w3: Web3, network: str, block_num: int):
        """Analyze a transaction for exploit patterns"""
        try:
            # Skip simple ETH transfers
            if not tx.input or len(tx.input) < 10:
                return
            
            # Check for exploit patterns
            for exploit_type, signature in self.exploit_signatures.items():
                if await self._detect_exploit_pattern(tx, signature, w3, network):
                    # Generate alert
                    alert = await self._generate_alert(tx, exploit_type, signature, w3, network, block_num)
                    if alert:
                        await self._process_alert(alert)
        
        except Exception as e:
            logger.error(f"‚ùå Error analyzing transaction: {e}")
    
    async def _detect_exploit_pattern(self, tx, signature: Dict[str, Any], w3: Web3, network: str) -> bool:
        """Detect if transaction matches exploit pattern"""
        try:
            # Check bytecode patterns
            if 'patterns' in signature:
                for pattern in signature['patterns']:
                    if pattern in tx.input.hex():
                        return True
            
            # Check transaction value
            if tx.value:
                value_eth = float(w3.from_wei(tx.value, 'ether'))
                if value_eth > 10.0:  # Large value transaction
                    return True
            
            # Check gas usage
            if tx.gas and tx.gas > 1000000:  # High gas usage
                return True
            
            # Check for contract interaction
            if tx.to and len(w3.eth.get_code(tx.to)) > 2:
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"‚ùå Error detecting exploit pattern: {e}")
            return False
    
    async def _generate_alert(self, tx, exploit_type: str, signature: Dict[str, Any], w3: Web3, network: str, block_num: int) -> Optional[ExploitAlert]:
        """Generate exploit alert"""
        try:
            # Calculate alert parameters
            alert_id = f"alert_{int(time.time())}_{tx.hash.hex()[:8]}"
            timestamp = datetime.now().isoformat()
            
            # Estimate profit
            estimated_profit = self._estimate_exploit_profit(tx, w3)
            
            # Calculate risk score
            risk_score = self._calculate_risk_score(signature['severity'], estimated_profit)
            
            # Generate alert message
            alert_message = f"üö® POTENTIAL {exploit_type.upper()} DETECTED!\\n"
            alert_message += f"üìç Network: {network}\\n"
            alert_message += f"üéØ Target: {tx.to}\\n"
            alert_message += f"üí∞ Estimated Profit: {estimated_profit:.2f} ETH\\n"
            alert_message += f"‚ö†Ô∏è Severity: {signature['severity'].upper()}\\n"
            alert_message += f"üîó TX Hash: {tx.hash.hex()}\\n"
            
            # Create alert
            alert = ExploitAlert(
                alert_id=alert_id,
                timestamp=timestamp,
                severity=signature['severity'],
                vulnerability_type=exploit_type.replace('_', ' ').title(),
                target_address=tx.to or '',
                target_name='Unknown',
                network=network,
                exploit_detected=True,
                exploit_method=signature.get('detection_method', 'pattern_matching'),
                estimated_profit=estimated_profit,
                confidence=min(risk_score / 10.0, 1.0),
                risk_score=risk_score,
                action_required=signature['severity'] == 'critical',
                alert_message=alert_message,
                transaction_hash=tx.hash.hex(),
                block_number=block_num,
                gas_used=tx.gas or 0,
                gas_cost=float(w3.from_wei((tx.gas or 0) * (tx.gasPrice or 0), 'ether')),
                attacker_address=tx['from'].hex() if tx['from'] else '',
                victim_address=tx.to or '',
                status='detected',
                response_time=0.0,
                metadata={
                    'signature_type': exploit_type,
                    'detection_method': signature.get('detection_method', 'pattern_matching'),
                    'response_priority': signature.get('response_priority', 'normal'),
                    'transaction_input': tx.input.hex()[:100] + '...' if len(tx.input.hex()) > 100 else tx.input.hex()
                }
            )
            
            return alert
        
        except Exception as e:
            logger.error(f"‚ùå Error generating alert: {e}")
            return None
    
    def _estimate_exploit_profit(self, tx, w3: Web3) -> float:
        """Estimate potential exploit profit"""
        try:
            # Base estimation on transaction value
            if tx.value:
                value_eth = float(w3.from_wei(tx.value, 'ether'))
                return min(value_eth * 0.2, 10.0)  # 20% of value, max 10 ETH
            
            # Estimate based on gas cost
            if tx.gas and tx.gasPrice:
                gas_cost = float(w3.from_wei(tx.gas * tx.gasPrice, 'ether'))
                return max(gas_cost * 5, 0.5)  # At least 0.5 ETH
            
            return 1.0  # Default estimation
        
        except Exception:
            return 1.0
    
    def _calculate_risk_score(self, severity: str, profit: float) -> float:
        """Calculate risk score based on severity and profit"""
        severity_scores = {
            'critical': 9.0,
            'high': 7.0,
            'medium': 5.0,
            'low': 3.0
        }
        
        base_score = severity_scores.get(severity, 5.0)
        profit_multiplier = min(profit / 5.0, 2.0)  # Max 2x multiplier
        
        return min(base_score * profit_multiplier, 10.0)
    
    async def _process_alert(self, alert: ExploitAlert):
        """Process and distribute alert"""
        try:
            # Add to queue
            self.alert_queue.put(alert)
            
            # Update statistics
            self.monitoring_stats['total_alerts'] += 1
            if alert.severity == 'critical':
                self.monitoring_stats['critical_alerts'] += 1
            
            # Add to history
            self.alert_history.append(alert)
            
            # Send notifications
            await self._send_alert_notifications(alert)
            
            # Update most common statistics
            if not self.monitoring_stats['most_common_vulnerability']:
                self.monitoring_stats['most_common_vulnerability'] = alert.vulnerability_type
            
            # Log alert
            logger.warning(f"üö® ALERT: {alert.vulnerability_type} detected on {alert.network}")
            logger.warning(f"   Target: {alert.target_address}")
            logger.warning(f"   Profit: {alert.estimated_profit:.2f} ETH")
            logger.warning(f"   TX: {alert.transaction_hash}")
        
        except Exception as e:
            logger.error(f"‚ùå Error processing alert: {e}")
    
    async def _send_alert_notifications(self, alert: ExploitAlert):
        """Send alert notifications"""
        try:
            # Email notification
            if self.config['alert_config']['email_enabled']:
                await self._send_email_alert(alert)
            
            # Webhook notification
            if self.config['alert_config']['webhook_url']:
                await self._send_webhook_alert(alert)
            
            # Discord notification
            if self.config['alert_config']['discord_webhook']:
                await self._send_discord_alert(alert)
            
            # Telegram notification
            if self.config['alert_config']['telegram_bot_token']:
                await self._send_telegram_alert(alert)
        
        except Exception as e:
            logger.error(f"‚ùå Error sending notifications: {e}")
    
    async def _send_email_alert(self, alert: ExploitAlert):
        """Send email alert"""
        try:
            if not self.config['alert_config']['email_user']:
                return
            
            msg = MIMEText(alert.alert_message)
            msg['Subject'] = f"üö® EXPLOIT ALERT: {alert.vulnerability_type}"
            msg['From'] = self.config['alert_config']['email_user']
            
            for recipient in self.config['alert_config']['alert_recipients']:
                if recipient.strip():
                    msg['To'] = recipient.strip()
                    
                    # Send email (simplified - in production use proper email client)
                    logger.info(f"üìß Email alert would be sent to {recipient}")
        
        except Exception as e:
            logger.error(f"‚ùå Error sending email alert: {e}")
    
    async def _send_webhook_alert(self, alert: ExploitAlert):
        """Send webhook alert"""
        try:
            webhook_url = self.config['alert_config']['webhook_url']
            if not webhook_url:
                return
            
            payload = {
                'alert_id': alert.alert_id,
                'timestamp': alert.timestamp,
                'severity': alert.severity,
                'vulnerability_type': alert.vulnerability_type,
                'target_address': alert.target_address,
                'network': alert.network,
                'estimated_profit': alert.estimated_profit,
                'transaction_hash': alert.transaction_hash,
                'risk_score': alert.risk_score
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(webhook_url, json=payload) as response:
                    if response.status == 200:
                        logger.info("üì° Webhook alert sent successfully")
                    else:
                        logger.error(f"‚ùå Webhook alert failed: {response.status}")
        
        except Exception as e:
            logger.error(f"‚ùå Error sending webhook alert: {e}")
    
    async def _send_discord_alert(self, alert: ExploitAlert):
        """Send Discord alert"""
        try:
            webhook_url = self.config['alert_config']['discord_webhook']
            if not webhook_url:
                return
            
            # Create Discord embed
            embed = {
                'title': f"üö® EXPLOIT ALERT: {alert.vulnerability_type}",
                'description': alert.alert_message,
                'color': 0xff0000 if alert.severity == 'critical' else 0xffaa00,
                'fields': [
                    {'name': 'Network', 'value': alert.network, 'inline': True},
                    {'name': 'Severity', 'value': alert.severity.upper(), 'inline': True},
                    {'name': 'Estimated Profit', 'value': f"{alert.estimated_profit:.2f} ETH", 'inline': True},
                    {'name': 'Risk Score', 'value': f"{alert.risk_score:.1f}/10", 'inline': True},
                    {'name': 'Transaction', 'value': f"[{alert.transaction_hash[:16]}...](https://etherscan.io/tx/{alert.transaction_hash})", 'inline': False}
                ],
                'timestamp': alert.timestamp
            }
            
            payload = {
                'embeds': [embed]
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(webhook_url, json=payload) as response:
                    if response.status == 204:
                        logger.info("üí¨ Discord alert sent successfully")
                    else:
                        logger.error(f"‚ùå Discord alert failed: {response.status}")
        
        except Exception as e:
            logger.error(f"‚ùå Error sending Discord alert: {e}")
    
    async def _send_telegram_alert(self, alert: ExploitAlert):
        """Send Telegram alert"""
        try:
            bot_token = self.config['alert_config']['telegram_bot_token']
            chat_id = self.config['alert_config']['telegram_chat_id']
            
            if not bot_token or not chat_id:
                return
            
            message = alert.alert_message.replace('\\n', '\\n')
            
            url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
            payload = {
                'chat_id': chat_id,
                'text': message,
                'parse_mode': 'Markdown'
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=payload) as response:
                    if response.status == 200:
                        logger.info("üì± Telegram alert sent successfully")
                    else:
                        logger.error(f"‚ùå Telegram alert failed: {response.status}")
        
        except Exception as e:
            logger.error(f"‚ùå Error sending Telegram alert: {e}")
    
    async def start_monitoring(self):
        """Start real-time monitoring"""
        logger.info("üöÄ STARTING REAL-TIME EXPLOIT MONITORING")
        print("=" * 100)
        print("üéØ SHADOWSCAN REAL-TIME EXPLOIT MONITORING")
        print("üì° MONITORING BLOCKCHAIN FOR EXPLOITS")
        print("üö® REAL-TIME ALERT SYSTEM ACTIVATED")
        print("=" * 100)
        
        self.monitoring_active = True
        
        try:
            print(f"‚úÖ Configuration loaded")
            print(f"   Networks: {list(self.web3_providers.keys())}")
            print(f"   Check interval: {self.config['monitoring_config']['check_interval']}s")
            print(f"   Alert threshold: {self.config['monitoring_config']['alert_threshold']}")
            print(f"   Email notifications: {'enabled' if self.config['alert_config']['email_enabled'] else 'disabled'}")
            
            # Start monitoring tasks
            self.monitoring_tasks = []
            
            # Network monitoring tasks
            for network in self.web3_providers.keys():
                task = asyncio.create_task(self._monitor_network_continuously(network))
                self.monitoring_tasks.append(task)
            
            # Alert processing task
            alert_task = asyncio.create_task(self._process_alert_queue())
            self.monitoring_tasks.append(alert_task)
            
            # Statistics reporting task
            stats_task = asyncio.create_task(self._report_statistics())
            self.monitoring_tasks.append(stats_task)
            
            print("\\nüöÄ MONITORING STARTED!")
            print("üì° Real-time exploit detection active")
            print("üö® Alert system activated")
            print("‚èπÔ∏è Press Ctrl+C to stop monitoring")
            
            # Keep monitoring active
            while self.monitoring_active:
                await asyncio.sleep(1)
        
        except KeyboardInterrupt:
            print("\\n\\n‚èπÔ∏è STOPPING MONITORING...")
            await self.stop_monitoring()
        except Exception as e:
            logger.error(f"‚ùå Error in monitoring: {e}")
            await self.stop_monitoring()
    
    async def _monitor_network_continuously(self, network: str):
        """Monitor a network continuously"""
        while self.monitoring_active:
            try:
                await self.monitor_network(network)
                await asyncio.sleep(self.config['monitoring_config']['check_interval'])
            except Exception as e:
                logger.error(f"‚ùå Error monitoring {network}: {e}")
                await asyncio.sleep(5)  # Wait before retrying
    
    async def _process_alert_queue(self):
        """Process alert queue"""
        while self.monitoring_active:
            try:
                # Process alerts from queue
                while not self.alert_queue.empty():
                    try:
                        alert = self.alert_queue.get_nowait()
                        # Alert already processed in _process_alert
                        self.alert_queue.task_done()
                    except Empty:
                        break
                
                await asyncio.sleep(1)
            
            except Exception as e:
                logger.error(f"‚ùå Error processing alert queue: {e}")
                await asyncio.sleep(5)
    
    async def _report_statistics(self):
        """Report monitoring statistics"""
        while self.monitoring_active:
            try:
                # Update statistics
                if self.alert_history:
                    recent_alerts = [a for a in self.alert_history if 
                                   datetime.fromisoformat(a.timestamp) > datetime.now() - timedelta(minutes=5)]
                    
                    self.monitoring_stats['exploits_detected'] = len(recent_alerts)
                    
                    # Calculate most active network
                    network_counts = {}
                    for alert in recent_alerts:
                        network_counts[alert.network] = network_counts.get(alert.network, 0) + 1
                    
                    if network_counts:
                        self.monitoring_stats['most_active_network'] = max(
                            network_counts, 
                            key=network_counts.get
                        )
                
                # Print statistics
                print(f"\\nüìä MONITORING STATISTICS")
                print("=" * 50)
                print(f"üéØ Total Alerts: {self.monitoring_stats['total_alerts']}")
                print(f"üí• Critical Alerts: {self.monitoring_stats['critical_alerts']}")
                print(f"üîç Recent Exploits: {self.monitoring_stats['exploits_detected']}")
                print(f"üåê Most Active Network: {self.monitoring_stats['most_active_network']}")
                print(f"üèÜ Most Common Vulnerability: {self.monitoring_stats['most_common_vulnerability']}")
                print(f"‚è±Ô∏è Uptime: {datetime.now() - datetime.fromisoformat(self.start_time)}")
                
                await asyncio.sleep(60)  # Report every minute
            
            except Exception as e:
                logger.error(f"‚ùå Error reporting statistics: {e}")
                await asyncio.sleep(10)
    
    async def stop_monitoring(self):
        """Stop monitoring"""
        self.monitoring_active = False
        
        # Cancel all tasks
        for task in self.monitoring_tasks:
            task.cancel()
        
        # Wait for tasks to finish
        if self.monitoring_tasks:
            await asyncio.gather(*self.monitoring_tasks, return_exceptions=True)
        
        print("üõë MONITORING STOPPED")
        print(f"üìä Final Statistics:")
        print(f"   Total Alerts: {self.monitoring_stats['total_alerts']}")
        print(f"   Critical Alerts: {self.monitoring_stats['critical_alerts']}")
        print(f"   Exploits Detected: {self.monitoring_stats['exploits_detected']}")

async def main():
    """Main function"""
    monitor = RealTimeExploitMonitor()
    monitor.start_time = datetime.now().isoformat()
    await monitor.start_monitoring()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\\nüëã Monitoring stopped by user")