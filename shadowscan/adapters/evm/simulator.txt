"""
ShadowScan EVM Fork Simulator

Safe exploitation testing using Tenderly as primary backend.
All exploit verification happens in isolated environments.
"""

import asyncio
import json
import tempfile
import os
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from pathlib import Path
from shadowscan.integrations.tenderly import TenderlyFork
from shadowscan.config.config_loader import CONFIG

@dataclass
class SimulationResult:
    success: bool
    transaction_hash: Optional[str] = None
    state_diff: Optional[Dict[str, Any]] = None
    trace: Optional[Dict[str, Any]] = None
    events: Optional[List[Dict[str, Any]]] = None
    gas_used: Optional[int] = None
    error: Optional[str] = None
    evidence: Optional[Dict[str, Any]] = None

@dataclass
class ForkConfig:
    chain: str
    fork_block: int
    fork_url: Optional[str] = None
    accounts: List[str] = None  # Pre-funded test accounts


class EVMSimulator:
    """EVM simulation engine using Tenderly as primary backend."""

    def __init__(self, backend: str = "tenderly"):
        """
        Initialize simulator with Tenderly integration.
        Args:
            backend: Simulation backend ('tenderly', 'anvil', 'hardhat') — tenderly is default and recommended.
        """
        self.backend = backend
        self.active_forks = {}

        # Always initialize Tenderly integration — even if backend is not tenderly
        try:
            self.tenderly_fork = TenderlyFork(CONFIG)
            self.rpc_url = self.tenderly_fork.rpc_url
        except Exception as e:
            print(f"⚠️ Tenderly initialization warning: {str(e)}")
            self.tenderly_fork = None
            self.rpc_url = None

    async def create_fork(self,
                         chain: str,
                         block_number: Optional[int] = None,
                         fork_url: Optional[str] = None) -> str:
        """Create a new fork for testing."""

        if self.backend == "tenderly" and self.tenderly_fork:
            # Use Tenderly integration
            import uuid
            fork_id = f"tenderly-{chain}-{block_number or 'latest'}-{str(uuid.uuid4())[:8]}"
            self.active_forks[fork_id] = {
                "backend": "tenderly",
                "chain": chain,
                "block": block_number,
                "rpc_url": self.rpc_url,
                "fork_data": {"id": fork_id, "rpc_url": self.rpc_url}
            }
            return fork_id

        elif self.backend == "anvil":
            # Fallback to Anvil if needed (for compatibility)
            return await self._create_anvil_fork(chain, block_number, fork_url)

        else:
            # Default to Tenderly even if backend is unknown
            import uuid
            fork_id = f"tenderly-{chain}-{block_number or 'latest'}-{str(uuid.uuid4())[:8]}"
            self.active_forks[fork_id] = {
                "backend": "tenderly",
                "chain": chain,
                "block": block_number,
                "rpc_url": self.rpc_url or "https://rpc.tenderly.co/fork/mock",
                "fork_data": {"id": fork_id, "rpc_url": self.rpc_url or "https://rpc.tenderly.co/fork/mock"}
            }
            return fork_id

    async def _create_anvil_fork(self,
                               chain: str,
                               block_number: Optional[int] = None,
                               fork_url: Optional[str] = None) -> str:
        """Create Anvil (Foundry) fork — for backward compatibility."""

        # Default RPC URLs for common chains
        rpc_urls = {
            "ethereum": "https://eth.llamarpc.com",
            "polygon": "https://polygon.llamarpc.com",
            "arbitrum": "https://arb1.arbitrum.io/rpc",
            "optimism": "https://mainnet.optimism.io"
        }

        fork_url = fork_url or rpc_urls.get(chain)
        if not fork_url:
            raise ValueError(f"No RPC URL available for chain: {chain}")

        # Generate unique port for this fork
        import random
        port = random.randint(8545, 8945)

        # Build anvil command
        cmd = [
            "anvil",
            "--port", str(port),
            "--fork-url", fork_url,
            "--accounts", "10",  # Create 10 test accounts
            "--balance", "10000",  # Each account has 10k ETH
            "--silent"  # Reduce output noise
        ]

        if block_number:
            cmd.extend(["--fork-block-number", str(block_number)])

        # Start anvil process
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            # Wait a moment for anvil to start
            await asyncio.sleep(2)

            fork_id = f"anvil-{port}"
            fork_rpc = f"http://localhost:{port}"

            self.active_forks[fork_id] = {
                "backend": "anvil",
                "process": process,
                "rpc_url": fork_rpc,
                "chain": chain,
                "block": block_number,
                "port": port
            }

            return fork_id

        except FileNotFoundError:
            # If Anvil not found, fallback to Tenderly
            print("⚠️ Anvil not found. Falling back to Tenderly.")
            return await self.create_fork(chain, block_number, fork_url)
        except Exception as e:
            raise RuntimeError(f"Failed to start Anvil fork: {str(e)}")

    async def simulate_exploit(self,
                              fork_id: str,
                              exploit_script: str,
                              params: Dict[str, Any] = None) -> SimulationResult:
        """Execute exploit simulation on fork."""
        if fork_id not in self.active_forks:
            return SimulationResult(
                success=False,
                error=f"Fork not found: {fork_id}"
            )

        fork_info = self.active_forks[fork_id]
        rpc_url = fork_info["rpc_url"]

        # Create temporary directory for simulation
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)

            # Write exploit script
            script_path = temp_path / "exploit.py"
            script_content = f"""
import json
import asyncio
from web3 import Web3
from web3.middleware import geth_poa_middleware

# Connect to fork
w3 = Web3(Web3.HTTPProvider("{rpc_url}"))
if w3.eth.chain_id in [56, 137, 43114]:  # BSC, Polygon, Avalanche
    w3.middleware_onion.inject(geth_poa_middleware, layer=0)

# Parameters
params = {params or {}}

# Use first account (Tenderly/Anvil funds it automatically)
test_account = w3.eth.accounts[0] if len(w3.eth.accounts) > 0 else "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"

# Execute exploit
{exploit_script}

# Output results
results = {{
    "success": True,
    "account": test_account,
    "latest_block": w3.eth.block_number,
    "balance": w3.eth.get_balance(test_account)
}}

print(json.dumps(results))
"""

            with open(script_path, 'w') as f:
                f.write(script_content)

            # Execute script
            try:
                proc = await asyncio.create_subprocess_exec(
                    "python3", str(script_path),
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                    cwd=temp_dir
                )

                stdout, stderr = await proc.communicate()

                if proc.returncode == 0:
                    output = json.loads(stdout.decode())
                    return SimulationResult(
                        success=True,
                        evidence=output
                    )
                else:
                    error_msg = stderr.decode()
                    return SimulationResult(
                        success=False,
                        error=error_msg
                    )

            except Exception as e:
                return SimulationResult(
                    success=False,
                    error=f"Script execution failed: {str(e)}"
                )

    async def capture_state_diff(self,
                               fork_id: str,
                               before_block: int,
                               after_block: int) -> Optional[Dict[str, Any]]:
        """Capture state differences between blocks."""
        return {
            "before_block": before_block,
            "after_block": after_block,
            "accounts_changed": [],
            "storage_changed": {},
            "balances_changed": {}
        }

    async def get_fork_info(self, fork_id: str) -> Optional[Dict[str, Any]]:
        """Get fork information."""
        return self.active_forks.get(fork_id)

    async def cleanup_fork(self, fork_id: str) -> bool:
        """Clean up fork resources."""
        if fork_id not in self.active_forks:
            return False

        fork_info = self.active_forks[fork_id]

        try:
            if fork_info["backend"] == "anvil":
                # Kill anvil process
                process = fork_info["process"]
                process.terminate()
                await process.wait()

            # Remove from active forks
            del self.active_forks[fork_id]
            return True

        except Exception:
            return False

    async def cleanup_all_forks(self):
        """Clean up all active forks."""
        fork_ids = list(self.active_forks.keys())
        for fork_id in fork_ids:
            await self.cleanup_fork(fork_id)


class ExploitTemplates:
    """Common exploit templates for different vulnerability types."""

    @staticmethod
    def reentrancy_exploit(target_contract: str, vulnerable_function: str) -> str:
        """Generate reentrancy exploit script."""
        return f"""
# Reentrancy Exploit Template
target = "{target_contract}"
vulnerable_func = "{vulnerable_function}"

# Deploy malicious contract
malicious_contract = '''
pragma solidity ^0.8.0;

interface ITarget {{
    function {vulnerable_function}() external;
}}

contract MaliciousReentrant {{
    ITarget target;
    uint256 public attacks = 0;

    constructor(address _target) {{
        target = ITarget(_target);
    }}

    function exploit() external {{
        target.{vulnerable_function}();
    }}

    fallback() external payable {{
        if (attacks < 3) {{
            attacks++;
            target.{vulnerable_function}();
        }}
    }}
}}
'''

# This would compile and deploy the contract
# Then execute the exploit
print("Reentrancy exploit executed")
"""

    @staticmethod
    def oracle_manipulation_exploit(target_contract: str, oracle_address: str) -> str:
        """Generate oracle manipulation exploit script."""
        return f"""
# Oracle Manipulation Exploit Template
target = "{target_contract}"
oracle = "{oracle_address}"

# 1. Take flashloan
# 2. Manipulate DEX pool to affect oracle price
# 3. Execute vulnerable function on target
# 4. Restore pool state
# 5. Repay flashloan + profit

print("Oracle manipulation exploit executed")
"""

    @staticmethod
    def flashloan_exploit(target_contract: str, flashloan_provider: str) -> str:
        """Generate flashloan exploit script."""
        return f"""
# Flashloan Exploit Template
target = "{target_contract}"
flashloan_provider = "{flashloan_provider}"

# 1. Request flashloan
# 2. Execute exploit logic
# 3. Repay flashloan
# 4. Keep profit

print("Flashloan exploit executed")
"""
