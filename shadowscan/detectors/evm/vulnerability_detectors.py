"""
ShadowScan EVM Vulnerability Detectors

This module contains comprehensive vulnerability detectors for EVM smart contracts.
Each detector implements a specific security analysis with robust detection logic.
"""

import asyncio
import re
import math
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass
from decimal import Decimal
from enum import Enum

from shadowscan.adapters.evm.provider import EVMProvider
from shadowscan.models.findings import Finding, SeverityLevel


class VulnerabilityType(Enum):
    """Enumeration of vulnerability types."""
    REENTRANCY = "reentrancy"
    FLASHLOAN = "flashloan"
    ORACLE_MANIPULATION = "oracle_manipulation"
    ACCESS_CONTROL = "access_control"
    INTEGER_OVERFLOW = "integer_overflow"
    UNCHECKED_CALLS = "unchecked_calls"
    FRONT_RUNNING = "front_running"
    TIME_MANIPULATION = "time_manipulation"
    PROXY_MISUSE = "proxy_misuse"
    TOKEN_APPROVAL = "token_approval"
    FEE_MANIPULATION = "fee_manipulation"
    SLIPPAGE_PROTECTION = "slippage_protection"
    PAUSE_MECHANISM = "pause_mechanism"
    UPGRADE_MISUSE = "upgrade_misuse"
    MULTICALL_EXPLOIT = "multicall_exploit"
    SIGNATURE_REPLAY = "signature_replay"
    DELEGATECALL_MISUSE = "delegatecall_misuse"
    STORAGE_COLLISION = "storage_collision"
    GAS_LIMITATION = "gas_limitation"
    SELFDESTRUCT_MISUSE = "selfdestruct_misuse"


@dataclass
class VulnerabilityFinding:
    """Represents a detected vulnerability."""
    vulnerability_type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    affected_functions: List[str]
    confidence: float  # 0.0 to 1.0
    exploitability_score: float  # 0.0 to 1.0
    impact_score: float  # 0.0 to 1.0
    evidence: Dict[str, Any]
    remediation: str
    references: List[str]


class BaseVulnerabilityDetector:
    """Base class for all vulnerability detectors."""
    
    def __init__(self, provider: EVMProvider):
        self.provider = provider
    
    async def screen(self, target_contract: str) -> List[VulnerabilityFinding]:
        """Screen contract for vulnerabilities. Override in subclasses."""
        raise NotImplementedError
    
    def _calculate_confidence(self, evidence: Dict[str, Any]) -> float:
        """Calculate confidence score based on evidence strength."""
        # Default implementation - override in subclasses
        return 0.7
    
    def _calculate_impact(self, vulnerability_type: VulnerabilityType) -> float:
        """Calculate impact score based on vulnerability type."""
        impact_map = {
            VulnerabilityType.REENTRANCY: 0.9,
            VulnerabilityType.FLASHLOAN: 0.8,
            VulnerabilityType.ORACLE_MANIPULATION: 0.9,
            VulnerabilityType.ACCESS_CONTROL: 0.8,
            VulnerabilityType.INTEGER_OVERFLOW: 0.7,
            VulnerabilityType.UNCHECKED_CALLS: 0.6,
            VulnerabilityType.FRONT_RUNNING: 0.5,
            VulnerabilityType.TIME_MANIPULATION: 0.4,
            VulnerabilityType.PROXY_MISUSE: 0.7,
            VulnerabilityType.TOKEN_APPROVAL: 0.8,
            VulnerabilityType.FEE_MANIPULATION: 0.6,
            VulnerabilityType.SLIPPAGE_PROTECTION: 0.5,
            VulnerabilityType.PAUSE_MECHANISM: 0.3,
            VulnerabilityType.UPGRADE_MISUSE: 0.6,
            VulnerabilityType.MULTICALL_EXPLOIT: 0.7,
            VulnerabilityType.SIGNATURE_REPLAY: 0.8,
            VulnerabilityType.DELEGATECALL_MISUSE: 0.9,
            VulnerabilityType.STORAGE_COLLISION: 0.7,
            VulnerabilityType.GAS_LIMITATION: 0.4,
            VulnerabilityType.SELFDESTRUCT_MISUSE: 0.8
        }
        return impact_map.get(vulnerability_type, 0.5)


class ReentrancyDetector(BaseVulnerabilityDetector):
    """Detects reentrancy vulnerabilities."""
    
    def __init__(self, provider: EVMProvider):
        super().__init__(provider)
        self.dangerous_patterns = [
            r"call\.value",
            r"transfer\(",
            r"send\(",
            r"\.call\(",
        ]
        self.state_change_patterns = [
            r"balances\[",
            r"mapping\(",
            r"state\s+variables",
        ]
    
    async def screen(self, target_contract: str) -> List[VulnerabilityFinding]:
        findings = []
        
        try:
            contract_info = await self.provider.get_contract_info(target_contract)
            
            if not contract_info or not contract_info.source_code:
                return findings
            
            source_code = contract_info.source_code.lower()
            
            # Check for reentrancy patterns
            reentrancy_vulns = await self._detect_reentrancy_patterns(
                target_contract, source_code
            )
            
            for vuln in reentrancy_vulns:
                finding = VulnerabilityFinding(
                    vulnerability_type=VulnerabilityType.REENTRANCY,
                    severity=vuln['severity'],
                    title=f"Reentrancy Vulnerability: {vuln['type']}",
                    description=vuln['description'],
                    affected_functions=vuln['functions'],
                    confidence=vuln['confidence'],
                    exploitability_score=0.8,
                    impact_score=self._calculate_impact(VulnerabilityType.REENTRANCY),
                    evidence=vuln['evidence'],
                    remediation="Implement checks-effects-interactions pattern and use reentrancy guards",
                    references=["https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"]
                )
                findings.append(finding)
                
        except Exception as e:
            # Log error but continue
            pass
        
        return findings
    
    async def _detect_reentrancy_patterns(self, contract_address: str, source_code: str) -> List[Dict]:
        vulnerabilities = []
        
        # Check for call before update pattern
        call_before_update = self._find_call_before_update(source_code)
        if call_before_update:
            vulnerabilities.append({
                'type': 'Call Before Update',
                'severity': SeverityLevel.HIGH,
                'description': 'External call performed before state update, potential reentrancy risk',
                'functions': call_before_update['functions'],
                'confidence': 0.8,
                'evidence': {
                    'pattern': 'external_call_before_state_update',
                    'locations': call_before_update['locations'],
                    'code_snippets': call_before_update['snippets']
                }
            })
        
        # Check for missing reentrancy guard
        missing_guard = self._check_missing_reentrancy_guard(source_code)
        if missing_guard:
            vulnerabilities.append({
                'type': 'Missing Reentrancy Guard',
                'severity': SeverityLevel.MEDIUM,
                'description': 'Functions with external calls lack reentrancy protection',
                'functions': missing_guard['functions'],
                'confidence': 0.7,
                'evidence': {
                    'pattern': 'missing_reentrancy_guard',
                    'functions_with_calls': missing_guard['functions'],
                    'external_calls_found': missing_guard['external_calls']
                }
            })
        
        # Check for multiple calls in single function
        multiple_calls = self._check_multiple_calls(source_code)
        if multiple_calls:
            vulnerabilities.append({
                'type': 'Multiple External Calls',
                'severity': SeverityLevel.MEDIUM,
                'description': 'Multiple external calls in single function increase reentrancy risk',
                'functions': multiple_calls['functions'],
                'confidence': 0.6,
                'evidence': {
                    'pattern': 'multiple_external_calls',
                    'call_count': multiple_calls['call_count']
                }
            })
        
        return vulnerabilities
    
    def _find_call_before_update(self, source_code: str) -> Optional[Dict]:
        """Find functions that make external calls before state updates."""
        functions = re.findall(r'function\s+(\w+)\s*\([^)]*\)[^{]*\{([^}]*)\}', source_code)
        
        vulnerable_functions = []
        locations = []
        snippets = []
        
        for func_name, func_body in functions:
            call_pattern = r'\.(call|transfer|send)\('
            update_pattern = r'(balances|mapping|state)\s*[=\+\-]'
            
            calls = re.findall(call_pattern, func_body)
            updates = re.findall(update_pattern, func_body)
            
            if calls and updates:
                # Check if calls appear before updates (simplified)
                call_positions = [m.start() for m in re.finditer(call_pattern, func_body)]
                update_positions = [m.start() for m in re.finditer(update_pattern, func_body)]
                
                if call_positions and update_positions and min(call_positions) < min(update_positions):
                    vulnerable_functions.append(func_name)
                    locations.append(f"Function: {func_name}")
                    snippets.append(func_body[:200] + "...")
        
        if vulnerable_functions:
            return {
                'functions': vulnerable_functions,
                'locations': locations,
                'snippets': snippets
            }
        
        return None
    
    def _check_missing_reentrancy_guard(self, source_code: str) -> Optional[Dict]:
        """Check for missing reentrancy guards in functions with external calls."""
        # Look for functions with external calls
        functions_with_calls = []
        external_calls = []
        
        functions = re.findall(r'function\s+(\w+)\s*\([^)]*\)[^{]*\{([^}]*)\}', source_code)
        
        for func_name, func_body in functions:
            if re.search(r'\.(call|transfer|send)\(', func_body):
                functions_with_calls.append(func_name)
                # Find all external calls
                calls = re.findall(r'(\w+\.\w+\([^)]*\))', func_body)
                external_calls.extend(calls)
        
        # Check if reentrancy guard is implemented
        has_guard = bool(re.search(r'reentrancy_guard|no_reentrant|lock', source_code))
        
        if functions_with_calls and not has_guard:
            return {
                'functions': functions_with_calls,
                'external_calls': list(set(external_calls))
            }
        
        return None
    
    def _check_multiple_calls(self, source_code: str) -> Optional[Dict]:
        """Check for functions with multiple external calls."""
        functions = re.findall(r'function\s+(\w+)\s*\([^)]*\)[^{]*\{([^}]*)\}', source_code)
        
        multiple_call_functions = []
        max_calls = 0
        
        for func_name, func_body in functions:
            calls = re.findall(r'\.(call|transfer|send)\(', func_body)
            if len(calls) > 1:
                multiple_call_functions.append(func_name)
                max_calls = max(max_calls, len(calls))
        
        if multiple_call_functions:
            return {
                'functions': multiple_call_functions,
                'call_count': max_calls
            }
        
        return None


class FlashloanDetector(BaseVulnerabilityDetector):
    """Detects flash loan vulnerabilities."""
    
    async def screen(self, target_contract: str) -> List[VulnerabilityFinding]:
        findings = []
        
        try:
            contract_info = await self.provider.get_contract_info(target_contract)
            
            if not contract_info or not contract_info.source_code:
                return findings
            
            source_code = contract_info.source_code.lower()
            
            # Check for flash loan vulnerabilities
            flashloan_vulns = await self._detect_flashloan_vulnerabilities(
                target_contract, source_code
            )
            
            for vuln in flashloan_vulns:
                finding = VulnerabilityFinding(
                    vulnerability_type=VulnerabilityType.FLASHLOAN,
                    severity=vuln['severity'],
                    title=f"Flash Loan Vulnerability: {vuln['type']}",
                    description=vuln['description'],
                    affected_functions=vuln['functions'],
                    confidence=vuln['confidence'],
                    exploitability_score=0.9,
                    impact_score=self._calculate_impact(VulnerabilityType.FLASHLOAN),
                    evidence=vuln['evidence'],
                    remediation="Implement proper price validation and minimum time delays between operations",
                    references=["https://github.com/ConsenSys/awesome-blockchain-security#flash-loan-attacks"]
                )
                findings.append(finding)
                
        except Exception as e:
            pass
        
        return findings
    
    async def _detect_flashloan_vulnerabilities(self, contract_address: str, source_code: str) -> List[Dict]:
        vulnerabilities = []
        
        # Check for unvalidated price operations
        unvalidated_prices = self._check_unvalidated_prices(source_code)
        if unvalidated_prices:
            vulnerabilities.append({
                'type': 'Unvalidated Price Operations',
                'severity': SeverityLevel.HIGH,
                'description': 'Operations performed without price validation, vulnerable to flash loan manipulation',
                'functions': unvalidated_prices['functions'],
                'confidence': 0.8,
                'evidence': {
                    'pattern': 'unvalidated_price_operations',
                    'price_operations': unvalidated_prices['operations']
                }
            })
        
        # Check for missing TWAP usage
        missing_twap = self._check_missing_twap(source_code)
        if missing_twap:
            vulnerabilities.append({
                'type': 'Missing TWAP Protection',
                'severity': SeverityLevel.MEDIUM,
                'description': 'Price feeds without TWAP (Time Weighted Average Price) protection',
                'functions': missing_twap['functions'],
                'confidence': 0.7,
                'evidence': {
                    'pattern': 'missing_twap',
                    'price_feeds': missing_twap['feeds']
                }
            })
        
        # Check for insufficient collateral validation
        insufficient_collateral = self._check_insufficient_collateral_validation(source_code)
        if insufficient_collateral:
            vulnerabilities.append({
                'type': 'Insufficient Collateral Validation',
                'severity': SeverityLevel.CRITICAL,
                'description': 'Collateral validation can be bypassed using flash loans',
                'functions': insufficient_collateral['functions'],
                'confidence': 0.9,
                'evidence': {
                    'pattern': 'insufficient_collateral_validation',
                    'validation_points': insufficient_collateral['points']
                }
            })
        
        return vulnerabilities
    
    def _check_unvalidated_prices(self, source_code: str) -> Optional[Dict]:
        """Check for operations performed without price validation."""
        price_operations = re.findall(
            r'(getprice|getreserves|latestrounddata|convert|swap|liquidate)\s*\([^)]*\)',
            source_code
        )
        
        # Look for operations without time validation
        time_validation = re.search(r'(block\.timestamp|now)\s*[-+]', source_code)
        
        if price_operations and not time_validation:
            functions = re.findall(r'function\s+(\w+)\s*[^{]*\{[^}]*' + '|'.join(price_operations), source_code)
            return {
                'functions': list(set(functions)),
                'operations': price_operations
            }
        
        return None
    
    def _check_missing_twap(self, source_code: str) -> Optional[Dict]:
        """Check for missing TWAP usage in price feeds."""
        price_feeds = re.findall(r'(getreserves|getprice|latestrounddata)', source_code)
        twap_usage = re.search(r'(twap|time.*weighted|cumulative)', source_code)
        
        if price_feeds and not twap_usage:
            functions = re.findall(r'function\s+(\w+)\s*[^{]*\{[^}]*' + '|'.join(price_feeds), source_code)
            return {
                'functions': list(set(functions)),
                'feeds': list(set(price_feeds))
            }
        
        return None
    
    def _check_insufficient_collateral_validation(self, source_code: str) -> Optional[Dict]:
        """Check for insufficient collateral validation."""
        # Look for borrow/withdraw functions without proper validation
        borrow_functions = re.findall(r'function\s+(borrow|withdraw)\s*\([^)]*\)[^{]*\{([^}]*)\}', source_code)
        
        vulnerable_functions = []
        validation_points = []
        
        for func_name, func_body in borrow_functions:
            # Check if function validates collateral properly
            has_validation = bool(re.search(r'(collateral.*>=|balance.*>=|require.*collateral)', func_body))
            
            if not has_validation:
                vulnerable_functions.append(func_name)
                validation_points.append(f"{func_name}() lacks collateral validation")
        
        if vulnerable_functions:
            return {
                'functions': vulnerable_functions,
                'points': validation_points
            }
        
        return None


class AccessControlDetector(BaseVulnerabilityDetector):
    """Detects access control vulnerabilities."""
    
    async def screen(self, target_contract: str) -> List[VulnerabilityFinding]:
        findings = []
        
        try:
            contract_info = await self.provider.get_contract_info(target_contract)
            
            if not contract_info or not contract_info.source_code:
                return findings
            
            source_code = contract_info.source_code.lower()
            
            # Check for access control vulnerabilities
            access_vulns = await self._detect_access_control_vulnerabilities(
                target_contract, source_code
            )
            
            for vuln in access_vulns:
                finding = VulnerabilityFinding(
                    vulnerability_type=VulnerabilityType.ACCESS_CONTROL,
                    severity=vuln['severity'],
                    title=f"Access Control Vulnerability: {vuln['type']}",
                    description=vuln['description'],
                    affected_functions=vuln['functions'],
                    confidence=vuln['confidence'],
                    exploitability_score=0.7,
                    impact_score=self._calculate_impact(VulnerabilityType.ACCESS_CONTROL),
                    evidence=vuln['evidence'],
                    remediation="Implement proper access controls using modifiers and role-based permissions",
                    references=["https://consensys.github.io/smart-contract-best-practices/security-guidelines/access-control/"]
                )
                findings.append(finding)
                
        except Exception as e:
            pass
        
        return findings
    
    async def _detect_access_control_vulnerabilities(self, contract_address: str, source_code: str) -> List[Dict]:
        vulnerabilities = []
        
        # Check for missing owner-only modifiers
        missing_owner = self._check_missing_owner_controls(source_code)
        if missing_owner:
            vulnerabilities.append({
                'type': 'Missing Owner Controls',
                'severity': SeverityLevel.HIGH,
                'description': 'Critical functions lack owner-only access controls',
                'functions': missing_owner['functions'],
                'confidence': 0.8,
                'evidence': {
                    'pattern': 'missing_owner_controls',
                    'critical_functions': missing_owner['functions']
                }
            })
        
        # Check for uninitialized ownership
        uninitialized_ownership = self._check_uninitialized_ownership(source_code)
        if uninitialized_ownership:
            vulnerabilities.append({
                'type': 'Uninitialized Ownership',
                'severity': SeverityLevel.CRITICAL,
                'description': 'Ownership not properly initialized in constructor',
                'functions': ['constructor'],
                'confidence': 0.9,
                'evidence': {
                    'pattern': 'uninitialized_ownership',
                    'missing_initialization': uninitialized_ownership['missing']
                }
            })
        
        # Check for public sensitive functions
        public_sensitive = self._check_public_sensitive_functions(source_code)
        if public_sensitive:
            vulnerabilities.append({
                'type': 'Public Sensitive Functions',
                'severity': SeverityLevel.MEDIUM,
                'description': 'Sensitive functions are publicly accessible without proper controls',
                'functions': public_sensitive['functions'],
                'confidence': 0.7,
                'evidence': {
                    'pattern': 'public_sensitive_functions',
                    'sensitive_operations': public_sensitive['operations']
                }
            })
        
        return vulnerabilities
    
    def _check_missing_owner_controls(self, source_code: str) -> Optional[Dict]:
        """Check for functions that should be owner-only but lack controls."""
        critical_functions = re.findall(
            r'function\s+(withdraw|transferOwnership|renounceOwnership|mint|burn|pause|unpause)\s*\([^)]*\)\s*public',
            source_code
        )
        
        if critical_functions:
            return {
                'functions': critical_functions
            }
        
        return None
    
    def _check_uninitialized_ownership(self, source_code: str) -> Optional[Dict]:
        """Check if ownership is properly initialized."""
        has_constructor = bool(re.search(r'constructor\s*\([^)]*\)\s*\{', source_code))
        has_owner_variable = bool(re.search(r'owner\s*=\s*msg\.sender', source_code))
        
        if has_constructor and not has_owner_variable:
            return {
                'missing': ['owner initialization']
            }
        
        return None
    
    def _check_public_sensitive_functions(self, source_code: str) -> Optional[Dict]:
        """Check for public functions that perform sensitive operations."""
        sensitive_patterns = [
            r'function\s+\w+\s*\([^)]*\)\s*public\s*\{[^}]*selfdestruct\(',
            r'function\s+\w+\s*\([^)]*\)\s*public\s*\{[^}]*\.call\(.*value\)',
            r'function\s+\w+\s*\([^)]*\)\s*public\s*\{[^}]*transfer\('
        ]
        
        vulnerable_functions = []
        operations = []
        
        for pattern in sensitive_patterns:
            matches = re.findall(pattern, source_code)
            if matches:
                vulnerable_functions.extend(matches)
                operations.append(pattern.split('selfdestruct|call|transfer')[1].split('(')[0])
        
        if vulnerable_functions:
            return {
                'functions': list(set(vulnerable_functions)),
                'operations': operations
            }
        
        return None


class IntegerOverflowDetector(BaseVulnerabilityDetector):
    """Detects integer overflow/underflow vulnerabilities."""
    
    async def screen(self, target_contract: str) -> List[VulnerabilityFinding]:
        findings = []
        
        try:
            contract_info = await self.provider.get_contract_info(target_contract)
            
            if not contract_info or not contract_info.source_code:
                return findings
            
            source_code = contract_info.source_code.lower()
            
            # Check for integer overflow vulnerabilities
            overflow_vulns = await self._detect_integer_overflow_vulnerabilities(
                target_contract, source_code
            )
            
            for vuln in overflow_vulns:
                finding = VulnerabilityFinding(
                    vulnerability_type=VulnerabilityType.INTEGER_OVERFLOW,
                    severity=vuln['severity'],
                    title=f"Integer Overflow Vulnerability: {vuln['type']}",
                    description=vuln['description'],
                    affected_functions=vuln['functions'],
                    confidence=vuln['confidence'],
                    exploitability_score=0.6,
                    impact_score=self._calculate_impact(VulnerabilityType.INTEGER_OVERFLOW),
                    evidence=vuln['evidence'],
                    remediation="Use SafeMath library or Solidity 0.8+ which has built-in overflow protection",
                    references=["https://consensys.github.io/smart-contract-best-practices/security-guidelines/integer-overflow-and-underflow/"]
                )
                findings.append(finding)
                
        except Exception as e:
            pass
        
        return findings
    
    async def _detect_integer_overflow_vulnerabilities(self, contract_address: str, source_code: str) -> List[Dict]:
        vulnerabilities = []
        
        # Check for arithmetic operations without SafeMath
        unsafe_arithmetic = self._check_unsafe_arithmetic(source_code)
        if unsafe_arithmetic:
            vulnerabilities.append({
                'type': 'Unsafe Arithmetic Operations',
                'severity': SeverityLevel.MEDIUM,
                'description': 'Arithmetic operations performed without overflow protection',
                'functions': unsafe_arithmetic['functions'],
                'confidence': 0.7,
                'evidence': {
                    'pattern': 'unsafe_arithmetic',
                    'operations': unsafe_arithmetic['operations']
                }
            })
        
        # Check for array length manipulation
        array_length_issues = self._check_array_length_issues(source_code)
        if array_length_issues:
            vulnerabilities.append({
                'type': 'Array Length Manipulation',
                'severity': SeverityLevel.HIGH,
                'description': 'Array length can be manipulated to cause overflow',
                'functions': array_length_issues['functions'],
                'confidence': 0.8,
                'evidence': {
                    'pattern': 'array_length_manipulation',
                    'array_operations': array_length_issues['operations']
                }
            })
        
        # Check for unchecked increment/decrement
        unchecked_ops = self._check_unchecked_operations(source_code)
        if unchecked_ops:
            vulnerabilities.append({
                'type': 'Unchecked Operations',
                'severity': SeverityLevel.MEDIUM,
                'description': 'Increment/decrement operations without overflow checks',
                'functions': unchecked_ops['functions'],
                'confidence': 0.6,
                'evidence': {
                    'pattern': 'unchecked_operations',
                    'operations': unchecked_ops['operations']
                }
            })
        
        return vulnerabilities
    
    def _check_unsafe_arithmetic(self, source_code: str) -> Optional[Dict]:
        """Check for arithmetic operations without SafeMath."""
        # Look for +, -, *, / operations without SafeMath
        arithmetic_patterns = [
            r'\w+\s*\+\s*\w+',
            r'\w+\s*-\s*\w+',
            r'\w+\s*\*\s*\w+',
            r'\w+\s*/\s*\w+'
        ]
        
        unsafe_operations = []
        functions = []
        
        for pattern in arithmetic_patterns:
            matches = re.findall(pattern, source_code)
            if matches:
                unsafe_operations.extend(matches)
                # Find functions containing these operations
                func_matches = re.findall(r'function\s+(\w+)\s*[^{]*\{[^}]*' + pattern, source_code)
                functions.extend(func_matches)
        
        # Check if SafeMath is used
        uses_safemath = bool(re.search(r'(safemath|using.*for.*uint)', source_code))
        
        if unsafe_operations and not uses_safemath:
            return {
                'functions': list(set(functions)),
                'operations': unsafe_operations
            }
        
        return None
    
    def _check_array_length_issues(self, source_code: str) -> Optional[Dict]:
        """Check for array length manipulation issues."""
        array_patterns = [
            r'\w+\.length\s*\+\+',
            r'\w+\.length\s*--',
            r'\w+\.length\s*[+\-]\s*\d+'
        ]
        
        vulnerable_functions = []
        operations = []
        
        for pattern in array_patterns:
            matches = re.findall(pattern, source_code)
            if matches:
                operations.extend(matches)
                func_matches = re.findall(r'function\s+(\w+)\s*[^{]*\{[^}]*' + pattern, source_code)
                vulnerable_functions.extend(func_matches)
        
        if vulnerable_functions:
            return {
                'functions': list(set(vulnerable_functions)),
                'operations': operations
            }
        
        return None
    
    def _check_unchecked_operations(self, source_code: str) -> Optional[Dict]:
        """Check for unchecked increment/decrement operations."""
        unchecked_patterns = [
            r'\w+\+\+',
            r'\w+--',
            r'\+\+\w+',
            r'--\w+'
        ]
        
        vulnerable_functions = []
        operations = []
        
        for pattern in unchecked_patterns:
            matches = re.findall(pattern, source_code)
            if matches:
                operations.extend(matches)
                func_matches = re.findall(r'function\s+(\w+)\s*[^{]*\{[^}]*' + pattern, source_code)
                vulnerable_functions.extend(func_matches)
        
        if vulnerable_functions:
            return {
                'functions': list(set(vulnerable_functions)),
                'operations': operations
            }
        
        return None


# Factory function to create detectors
def create_vulnerability_detector(vulnerability_type: VulnerabilityType, provider: EVMProvider) -> BaseVulnerabilityDetector:
    """Factory function to create vulnerability detectors."""
    detector_map = {
        VulnerabilityType.REENTRANCY: ReentrancyDetector,
        VulnerabilityType.FLASHLOAN: FlashloanDetector,
        VulnerabilityType.ACCESS_CONTROL: AccessControlDetector,
        VulnerabilityType.INTEGER_OVERFLOW: IntegerOverflowDetector,
    }
    
    detector_class = detector_map.get(vulnerability_type)
    if detector_class:
        return detector_class(provider)
    
    # Return a generic detector for unsupported types
    return BaseVulnerabilityDetector(provider)