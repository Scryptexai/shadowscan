# shadowscan/collectors/evm/dex_discovery.py (Enhanced Version)
"""Enhanced DEX discovery with comprehensive factory log scanning."""

from web3 import Web3
from typing import List, Dict, Any, Optional, Set, Tuple
import logging
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
from decimal import Decimal
from eth_utils import keccak

from shadowscan.utils.schema import DexReference
from shadowscan.utils.helpers import format_wei, is_contract_address

logger = logging.getLogger(__name__)

class DexDiscovery:
    """Enhanced DEX discovery with factory log scanning and multi-protocol support."""
    
    def __init__(self, web3: Web3, max_workers: int = 8):
        self.web3 = web3
        self.max_workers = max_workers
        
        # Enhanced DEX factory configurations with comprehensive coverage
        self.dex_factories = {
            'uniswap_v2': {
                'factory': '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f',
                'router': '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D',
                'pair_created_topic': '0x0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9',
                'version': 'v2',
                'name': 'Uniswap V2'
            },
            'uniswap_v3': {
                'factory': '0x1F98431c8aD98523631AE4a59f267346ea31F984',
                'router': '0xE592427A0AEce92De3Edee1F18E0157C05861564',
                'pool_created_topic': '0x783cca1c0412dd0d695e784568c96da2e9c22ff989357a2e8b1d9b2b4e6b7118',
                'version': 'v3',
                'name': 'Uniswap V3'
            },
            'sushiswap': {
                'factory': '0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac',
                'router': '0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F',
                'pair_created_topic': '0x0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9',
                'version': 'v2',
                'name': 'SushiSwap'
            },
            'pancakeswap_v2': {
                'factory': '0x1097053Fd2ea711dad45caCcc45EfF7548fCB362',
                'router': '0x10ED43C718714eb63d5aA57B78B54704E256024E',
                'pair_created_topic': '0x0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9',
                'version': 'v2',
                'name': 'PancakeSwap V2'
            },
            'curve': {
                'registry': '0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5',
                'factory': '0xB9fC157394Af804a3578134A6585C0dc9cc990d4',
                'name': 'Curve Finance'
            },
            'balancer_v2': {
                'vault': '0xBA12222222228d8Ba445958a75a0704d566BF2C8',
                'factory': '0x8E9aa87E45f74CF4bb9fa6b65A2B4D3CCa60a95b',
                'name': 'Balancer V2'
            }
        }
        
        # Common pairing tokens for comprehensive discovery
        self.base_tokens = {
            'WETH': '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
            'USDC': '0xA0b86a33E6441cF0047f25C4AD19f2c7f84951e5',
            'USDT': '0xdAC17F958D2ee523a2206206994597C13D831ec7',
            'DAI': '0x6B175474E89094C44Da98b954EedeAC495271d0F',
            'WBTC': '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599',
            'FRAX': '0x853d955aCEf822Db058eb8505911ED77F175b99e',
            'BUSD': '0x4Fabb145d64652a948d72533023f6E7A623C7C53'
        }
        
        # Price APIs for liquidity calculation
        self.price_apis = [
            'https://api.coingecko.com/api/v3/simple/token_price/ethereum',
            'https://api.1inch.exchange/v4.0/1/quote'
        ]
    
    def discover_dex_relations(self, address: str, provider, chain: str = 'ethereum') -> List[DexReference]:
        """
        Enhanced DEX relationship discovery with factory log scanning.
        
        Args:
            address: Token/contract address to analyze
            provider: Web3 provider
            chain: Blockchain network
            
        Returns:
            List of DexReference objects with comprehensive DEX coverage
        """
        try:
            checksum_addr = Web3.to_checksum_address(address)
            logger.info(f"Enhanced DEX discovery for {checksum_addr}")
            
            all_dex_refs = []
            
            # Method 1: Factory log scanning (most comprehensive)
            factory_pairs = self._scan_factory_logs(checksum_addr)
            logger.info(f"Found {len(factory_pairs)} pairs from factory logs")
            
            # Method 2: Direct pair calculation
            calculated_pairs = self._calculate_direct_pairs(checksum_addr)
            logger.info(f"Found {len(calculated_pairs)} pairs from calculations")
            
            # Method 3: Curve and Balancer discovery
            curve_pools = self._discover_curve_pools(checksum_addr)
            logger.info(f"Found {len(curve_pools)} Curve pools")
            
            balancer_pools = self._discover_balancer_pools(checksum_addr)
            logger.info(f"Found {len(balancer_pools)} Balancer pools")
            
            # Combine all discoveries
            all_pairs = factory_pairs + calculated_pairs + curve_pools + balancer_pools
            
            # Remove duplicates and analyze liquidity
            unique_pairs = self._deduplicate_pairs(all_pairs)
            
            # Analyze liquidity for each pair in parallel
            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                future_to_pair = {
                    executor.submit(self._analyze_pair_liquidity, pair): pair 
                    for pair in unique_pairs
                }
                
                for future in as_completed(future_to_pair):
                    pair = future_to_pair[future]
                    try:
                        dex_ref = future.result()
                        if dex_ref and dex_ref.liquidity_usd > 100:  # Filter out dust
                            all_dex_refs.append(dex_ref)
                    except Exception as e:
                        logger.debug(f"Error analyzing pair {pair.get('pair_address', 'unknown')}: {e}")
            
            # Sort by liquidity descending
            all_dex_refs.sort(key=lambda x: x.liquidity_usd, reverse=True)
            
            logger.info(f"Enhanced discovery completed: {len(all_dex_refs)} DEX relationships found")
            return all_dex_refs
            
        except Exception as e:
            logger.error(f"Error in enhanced DEX discovery: {e}")
            return []
    
    def _scan_factory_logs(self, token_address: str) -> List[Dict[str, Any]]:
        """Scan factory logs for PairCreated/PoolCreated events."""
        pairs = []
        
        try:
            # Get recent blocks to scan (last 500k blocks ~ 2-3 months)
            current_block = self.web3.eth.block_number
            from_block = max(0, current_block - 500000)
            
            logger.info(f"Scanning factory logs from block {from_block} to {current_block}")
            
            for dex_name, config in self.dex_factories.items():
                if dex_name in ['curve', 'balancer_v2']:  # Handle separately
                    continue
                    
                try:
                    factory_address = config['factory']
                    topic = config.get('pair_created_topic') or config.get('pool_created_topic')
                    
                    if not topic:
                        continue
                    
                    # Get all PairCreated events from factory
                    logs = self.web3.eth.get_logs({
                        'address': factory_address,
                        'topics': [topic],
                        'fromBlock': from_block,
                        'toBlock': 'latest'
                    })
                    
                    logger.debug(f"Found {len(logs)} {dex_name} factory events")
                    
                    # Parse logs to find pairs involving our token
                    for log in logs:
                        pair_info = self._parse_factory_log(log, token_address, dex_name, config)
                        if pair_info:
                            pairs.append(pair_info)
                            
                except Exception as e:
                    logger.debug(f"Error scanning {dex_name} factory: {e}")
                    continue
            
            logger.info(f"Factory log scanning found {len(pairs)} pairs")
            return pairs
            
        except Exception as e:
            logger.error(f"Error scanning factory logs: {e}")
            return []
    
    def _parse_factory_log(self, log, target_token: str, dex_name: str, config: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Parse factory log to extract pair information."""
        try:
            if config['version'] == 'v2':
                # Uniswap V2 style: PairCreated(token0, token1, pair, uint)
                if len(log.topics) >= 3:
                    token0 = '0x' + log.topics[1].hex()[-40:]
                    token1 = '0x' + log.topics[2].hex()[-40:]
                    
                    # Check if our target token is involved
                    if target_token.lower() in [token0.lower(), token1.lower()]:
                        # Extract pair address from data
                        if len(log.data) >= 64:  # pair address + uint
                            pair_address = Web3.to_checksum_address('0x' + log.data.hex()[26:66])
                            
                            return {
                                'pair_address': pair_address,
                                'token0': Web3.to_checksum_address(token0),
                                'token1': Web3.to_checksum_address(token1),
                                'dex_name': dex_name,
                                'factory': log.address,
                                'router': config['router'],
                                'block_created': log.blockNumber,
                                'version': 'v2'
                            }
            
            elif config['version'] == 'v3':
                # Uniswap V3 style: PoolCreated(token0, token1, fee, tickSpacing, pool)
                if len(log.topics) >= 4 and len(log.data) >= 64:
                    token0 = '0x' + log.topics[1].hex()[-40:]
                    token1 = '0x' + log.topics[2].hex()[-40:]
                    fee = int(log.topics[3].hex(), 16)
                    
                    if target_token.lower() in [token0.lower(), token1.lower()]:
                        # Pool address is typically in the data
                        pool_address = Web3.to_checksum_address('0x' + log.data.hex()[-40:])
                        
                        return {
                            'pair_address': pool_address,
                            'token0': Web3.to_checksum_address(token0),
                            'token1': Web3.to_checksum_address(token1),
                            'dex_name': dex_name,
                            'factory': log.address,
                            'router': config['router'],
                            'fee_tier': str(fee),
                            'block_created': log.blockNumber,
                            'version': 'v3'
                        }
            
        except Exception as e:
            logger.debug(f"Error parsing factory log: {e}")
        
        return None
    
    def _calculate_direct_pairs(self, token_address: str) -> List[Dict[str, Any]]:
        """Calculate pair addresses directly using CREATE2."""
        pairs = []
        
        for dex_name, config in self.dex_factories.items():
            if dex_name in ['curve', 'balancer_v2'] or config.get('version') != 'v2':
                continue
                
            # Calculate pairs with common base tokens
            for base_name, base_address in self.base_tokens.items():
                if base_address.lower() == token_address.lower():
                    continue
                    
                try:
                    pair_address = self._compute_v2_pair_address(
                        token_address, base_address, config['factory']
                    )
                    
                    if pair_address and self._pair_exists(pair_address):
                        pairs.append({
                            'pair_address': pair_address,
                            'token0': token_address,
                            'token1': base_address,
                            'dex_name': dex_name,
                            'factory': config['factory'],
                            'router': config['router'],
                            'base_token': base_name,
                            'version': 'v2'
                        })
                        
                except Exception as e:
                    logger.debug(f"Error calculating {dex_name} pair with {base_name}: {e}")
        
        return pairs
    
    def _discover_curve_pools(self, token_address: str) -> List[Dict[str, Any]]:
        """Discover Curve pools containing the token."""
        pools = []
        
        try:
            curve_config = self.dex_factories.get('curve', {})
            registry_address = curve_config.get('registry')
            
            if not registry_address:
                return pools
            
            # Call find_pool_for_coins on Curve registry
            # This is a simplified implementation - full version would iterate through all pools
            
            for base_name, base_address in self.base_tokens.items():
                try:
                    # find_pool_for_coins(coin_a, coin_b) selector: 0x6982c1b7
                    call_data = (
                        '0x6982c1b7' +
                        token_address[2:].zfill(64) +
                        base_address[2:].zfill(64)
                    )
                    
                    result = self.web3.eth.call({
                        'to': registry_address,
                        'data': call_data
                    })
                    
                    if len(result) >= 32 and result != b'\x00' * 32:
                        pool_address = Web3.to_checksum_address(result[-20:])
                        
                        if pool_address != "0x0000000000000000000000000000000000000000":
                            pools.append({
                                'pair_address': pool_address,
                                'token0': token_address,
                                'token1': base_address,
                                'dex_name': 'curve',
                                'registry': registry_address,
                                'base_token': base_name,
                                'version': 'stable'
                            })
                            
                except Exception as e:
                    logger.debug(f"Error checking Curve pool with {base_name}: {e}")
            
        except Exception as e:
            logger.debug(f"Error discovering Curve pools: {e}")
        
        return pools
    
    def _discover_balancer_pools(self, token_address: str) -> List[Dict[str, Any]]:
        """Discover Balancer pools containing the token."""
        pools = []
        
        try:
            # This would require querying Balancer's subgraph or vault
            # For now, we'll implement a basic check
            balancer_config = self.dex_factories.get('balancer_v2', {})
            vault_address = balancer_config.get('vault')
            
            if not vault_address:
                return pools
            
            # Simplified Balancer discovery - would need more sophisticated querying
            # This is placeholder for full implementation
            
        except Exception as e:
            logger.debug(f"Error discovering Balancer pools: {e}")
        
        return pools
    
    def _compute_v2_pair_address(self, token_a: str, token_b: str, factory_address: str) -> Optional[str]:
        """Compute Uniswap V2 style pair address using CREATE2."""
        try:
            # Sort tokens
            if token_a.lower() > token_b.lower():
                token_a, token_b = token_b, token_a
            
            # Compute salt
            salt = keccak(
                bytes.fromhex(token_a[2:].zfill(64)) + 
                bytes.fromhex(token_b[2:].zfill(64))
            )
            
            # Different DEXes have different init code hashes
            init_code_hashes = {
                '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f': '96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f',  # Uniswap V2
                '0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac': 'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303',  # SushiSwap
            }
            
            init_code_hash = init_code_hashes.get(factory_address.lower())
            if not init_code_hash:
                # Default to Uniswap V2
                init_code_hash = '96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'
            
            # CREATE2 address calculation
            create2_input = (
                bytes.fromhex('ff') + 
                bytes.fromhex(factory_address[2:]) + 
                salt + 
                bytes.fromhex(init_code_hash)
            )
            
            pair_address = Web3.to_checksum_address(keccak(create2_input)[12:])
            return pair_address
            
        except Exception as e:
            logger.debug(f"Error computing V2 pair address: {e}")
            return None
    
    def _pair_exists(self, pair_address: str) -> bool:
        """Check if pair/pool contract exists."""
        try:
            code = self.web3.eth.get_code(pair_address)
            return len(code) > 0
        except Exception:
            return False
    
    def _deduplicate_pairs(self, pairs: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Remove duplicate pairs."""
        seen = set()
        unique_pairs = []
        
        for pair in pairs:
            pair_addr = pair.get('pair_address', '').lower()
            if pair_addr and pair_addr not in seen:
                seen.add(pair_addr)
                unique_pairs.append(pair)
        
        return unique_pairs
    
    def _analyze_pair_liquidity(self, pair_info: Dict[str, Any]) -> Optional[DexReference]:
        """Analyze liquidity for a pair with enhanced accuracy."""
        try:
            pair_address = pair_info['pair_address']
            dex_name = pair_info['dex_name']
            version = pair_info.get('version', 'v2')
            
            if version == 'v2' or dex_name == 'sushiswap':
                return self._analyze_v2_liquidity_enhanced(pair_info)
            elif version == 'v3':
                return self._analyze_v3_liquidity_enhanced(pair_info)
            elif dex_name == 'curve':
                return self._analyze_curve_liquidity(pair_info)
            else:
                return self._analyze_generic_liquidity(pair_info)
                
        except Exception as e:
            logger.debug(f"Error analyzing pair liquidity: {e}")
            return None
    
    def _analyze_v2_liquidity_enhanced(self, pair_info: Dict[str, Any]) -> Optional[DexReference]:
        """Enhanced V2 liquidity analysis with real price data."""
        try:
            pair_address = pair_info['pair_address']
            
            # Get reserves
            reserves_result = self.web3.eth.call({
                'to': pair_address,
                'data': '0x0902f1ac'  # getReserves()
            })
            
            if len(reserves_result) < 96:
                return None
            
            reserve0 = int.from_bytes(reserves_result[:32], byteorder='big')
            reserve1 = int.from_bytes(reserves_result[32:64], byteorder='big')
            
            if reserve0 == 0 or reserve1 == 0:
                return None
            
            # Get token decimals
            token0_decimals = self._get_token_decimals(pair_info['token0'])
            token1_decimals = self._get_token_decimals(pair_info['token1'])
            
            # Calculate USD liquidity using price APIs
            liquidity_usd = self._calculate_usd_liquidity(
                pair_info['token0'], reserve0, token0_decimals,
                pair_info['token1'], reserve1, token1_decimals
            )
            
            # Calculate depth score
            depth_score = min(1.0, liquidity_usd / 100000)  # Normalized to $100k
            
            return DexReference(
                pair=pair_address,
                router=pair_info.get('router', ''),
                reserves=[str(reserve0), str(reserve1)],
                liquidity_usd=liquidity_usd,
                depth_score=depth_score,
                dex_name=pair_info['dex_name'],
                fee_tier=pair_info.get('fee_tier')
            )
            
        except Exception as e:
            logger.debug(f"Error analyzing V2 liquidity: {e}")
            return None
    
    def _get_token_decimals(self, token_address: str) -> int:
        """Get token decimals."""
        try:
            result = self.web3.eth.call({
                'to': token_address,
                'data': '0x313ce567'  # decimals()
            })
            return int.from_bytes(result, byteorder='big')
        except Exception:
            return 18
    
    def _calculate_usd_liquidity(self, token0: str, reserve0: int, decimals0: int,
                                token1: str, reserve1: int, decimals1: int) -> float:
        """Calculate USD liquidity using price APIs."""
        try:
            # Known stablecoin addresses for direct USD calculation
            stablecoins = {
                '0xA0b86a33E6441cF0047f25C4AD19f2c7f84951e5': 1.0,  # USDC
                '0xdAC17F958D2ee523a2206206994597C13D831ec7': 1.0,  # USDT
                '0x6B175474E89094C44Da98b954EedeAC495271d0F': 1.0,  # DAI
            }
            
            # Calculate token amounts
            amount0 = reserve0 / (10 ** decimals0)
            amount1 = reserve1 / (10 ** decimals1)
            
            # Check if either token is a stablecoin
            if token0.lower() in stablecoins:
                return amount0 * 2  # Total liquidity is 2x one side
            elif token1.lower() in stablecoins:
                return amount1 * 2
            
            # Check if WETH is involved
            weth_address = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'
            eth_price_usd = 2500  # Approximate - would fetch from API in production
            
            if token0.lower() == weth_address.lower():
                return amount0 * eth_price_usd * 2
            elif token1.lower() == weth_address.lower():
                return amount1 * eth_price_usd * 2
            
            # For other pairs, estimate based on reserve values
            # This is a simplified calculation
            total_reserve_value = max(amount0, amount1) * 1000  # Rough estimate
            return min(total_reserve_value, 1000000)  # Cap at $1M
            
        except Exception as e:
            logger.debug(f"Error calculating USD liquidity: {e}")
            return 0.0
