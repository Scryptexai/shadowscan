# shadowscan/collectors/evm/oracle_intel.py (Enhanced Version)
"""Enhanced Oracle intelligence with multi-protocol asset detection."""

from web3 import Web3
from typing import Dict, Any, List, Optional, Set
import logging
import re
from concurrent.futures import ThreadPoolExecutor, as_completed
from eth_utils import keccak

from shadowscan.utils.schema import OracleInfo
from shadowscan.utils.helpers import is_contract_address, calculate_risk_score

logger = logging.getLogger(__name__)

class OracleIntel:
    """Enhanced oracle intelligence with multi-protocol asset detection."""
    
    def __init__(self, web3: Web3, max_workers: int = 4):
        self.web3 = web3
        self.max_workers = max_workers
        
        # Enhanced protocol detection with oracle asset usage
        self.defi_protocols = {
            'compound_v2': {
                'comptroller': '0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B',
                'price_oracle': '0x50ce56A3239671Ab62f185704Caedf626352741e',
                'markets': [
                    '0x5d3a536E4D6DbD6114cc1Ead35777bAB11E4B98', # cDAI
                    '0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9', # cUSDT
                    '0x39AA39c021dfbaE8faC545936693aC917d5E7563', # cUSDC
                ]
            },
            'aave_v2': {
                'lending_pool': '0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9',
                'price_oracle': '0xA50ba011c48153De246E5192C8f9258A2ba79Ca9',
                'oracle_sentinel': '0xeE1a2F7dA0A0a4B2F7a0a4B2F7a0a4B2F7a0a4B'
            },
            'aave_v3': {
                'pool': '0x87870Bca909D4C42E71d6E2c4C7C5C8D0a3B5f9E',
                'price_oracle': '0x54586bE62E3c3580375aE3723C145253060Ca0C2',
                'oracle_sentinel': '0x1234567890123456789012345678901234567890'
            },
            'makerdao': {
                'spot': '0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3',
                'vat': '0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B',
                'price_feeds': [
                    '0x773616E4d11A78F511299002da57A0a94577F1f4', # ETH/USD
                    '0xaE2C3F21896c02510aA187BdA0791cDA77083708', # BTC/USD
                ]
            },
            'chainlink': {
                'registry': '0x47Fb2585D2C56Fe188D0E6ec628a38b74fceeedf',
                'aggregators': {
                    'ETH/USD': '0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419',
                    'BTC/USD': '0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c',
                    'USDC/USD': '0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6',
                    'USDT/USD': '0x3E7d1eAB13ad0104d2750B8863b489D65364e32D'
                }
            },
            'yearn': {
                'registry': '0x50c1a2eA0a861A967D9d0FFE2AE4012c2E53804a',
                'oracle': '0x83d95e0D5f402511dB06817Aff3f9eA88224B030'
            },
            'curve': {
                'registry': '0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5',
                'crypto_registry': '0x8F942C20D02bEfc377D41445793068908E2250D0',
                'price_oracle': '0x25672ACA103b2f8D5c14e8166d2e9b9C0e4A17E7'
            },
            'synthetix': {
                'exchange_rates': '0xd69b189020EF614796578AfE4d10378c5e7e1138',
                'oracle': '0xaE55F163337A2A46733AA66dA9F35299f9A46e9e'
            }
        }
        
        # Token usage detection in protocols
        self.token_usage_patterns = {
            'collateral_asset': ['mint', 'deposit', 'supply', 'lock'],
            'borrowable_asset': ['borrow', 'flash', 'loan'],
            'oracle_asset': ['price', 'rate', 'oracle', 'feed'],
            'reward_token': ['reward', 'stake', 'farm', 'yield']
        }
        
        # Enhanced oracle function signatures
        self.oracle_selectors = {
            # Chainlink
            '0x50d25bcd': 'latestAnswer',
            '0xfeaf968c': 'latestRoundData', 
            '0x313ce567': 'decimals',
            '0x7284e416': 'description',
            
            # TWAP
            '0x0902f1ac': 'getReserves',
            '0x5909c0d5': 'price0CumulativeLast',
            '0x5a3d5493': 'price1CumulativeLast',
            '0x3850c7bd': 'slot0',
            '0x883bdbfd': 'observe',
            
            # Compound
            '0xfc57d4df': 'getUnderlyingPrice',
            '0x46d15f5a': 'getPriceFromAsset',
            
            # MakerDAO  
            '0x91afdfce': 'peek',
            '0x29ae8114': 'read',
            
            # Custom oracles
            '0x98d5fdca': 'getPrice',
            '0xe7c46d1b': 'latestPrice',
            '0xa035b1fe': 'price'
        }
    
    def gather_oracle_info(self, target_session: Dict[str, Any], provider) -> OracleInfo:
        """
        Enhanced oracle intelligence gathering with multi-protocol detection.
        
        Args:
            target_session: Session data containing contract info
            provider: Web3 provider
            
        Returns:
            Enhanced OracleInfo with protocol usage detection
        """
        try:
            target_address = target_session.get('target')
            if not target_address:
                return OracleInfo()
            
            logger.info(f"Enhanced oracle intelligence for {target_address}")
            
            oracle_info = OracleInfo()
            
            # Step 1: Direct oracle usage analysis
            direct_usage = self._analyze_direct_oracle_usage(target_session)
            oracle_info.type = direct_usage.get('type', 'unknown')
            oracle_info.sources.extend(direct_usage.get('sources', []))
            oracle_info.price_feeds.extend(direct_usage.get('price_feeds', []))
            
            # Step 2: Protocol asset usage detection (NEW)
            protocol_usage = self._detect_protocol_asset_usage(target_address)
            oracle_info.sources.extend(protocol_usage.get('oracle_sources', []))
            oracle_info.price_feeds.extend(protocol_usage.get('price_feeds', []))
            
            # Step 3: Cross-protocol oracle dependency analysis
            cross_deps = self._analyze_cross_protocol_dependencies(target_address)
            oracle_info.sources.extend(cross_deps.get('sources', []))
            
            # Step 4: DEX oracle usage from session
            dex_oracle_usage = self._analyze_dex_oracle_relationships(target_session)
            if dex_oracle_usage:
                oracle_info.type = dex_oracle_usage.get('type', oracle_info.type)
                oracle_info.sources.extend(dex_oracle_usage.get('sources', []))
                oracle_info.twap_window = dex_oracle_usage.get('twap_window')
            
            # Remove duplicates
            oracle_info.sources = list(set(oracle_info.sources))
            oracle_info.price_feeds = list(set(oracle_info.price_feeds))
            
            # Enhanced risk scoring
            oracle_info.twap_risk_score = self._calculate_enhanced_risk_score(oracle_info, target_session)
            
            logger.info(f"Enhanced oracle analysis complete: type={oracle_info.type}, "
                       f"sources={len(oracle_info.sources)}, feeds={len(oracle_info.price_feeds)}, "
                       f"risk={oracle_info.twap_risk_score:.2f}")
            
            return oracle_info
            
        except Exception as e:
            logger.error(f"Error in enhanced oracle intelligence: {e}")
            return OracleInfo()
    
    def _detect_protocol_asset_usage(self, target_address: str) -> Dict[str, List[str]]:
        """Detect if target token is used as oracle asset in DeFi protocols."""
        results = {
            'oracle_sources': [],
            'price_feeds': [],
            'protocol_usage': []
        }
        
        try:
            checksum_addr = Web3.to_checksum_address(target_address)
            
            # Check Compound V2
            compound_usage = self._check_compound_usage(checksum_addr)
            results['oracle_sources'].extend(compound_usage.get('oracles', []))
            results['protocol_usage'].extend(compound_usage.get('usage', []))
            
            # Check Aave V2/V3
            aave_usage = self._check_aave_usage(checksum_addr)
            results['oracle_sources'].extend(aave_usage.get('oracles', []))
            results['protocol_usage'].extend(aave_usage.get('usage', []))
            
            # Check MakerDAO
            maker_usage = self._check_makerdao_usage(checksum_addr)
            results['oracle_sources'].extend(maker_usage.get('oracles', []))
            results['protocol_usage'].extend(maker_usage.get('usage', []))
            
            # Check Chainlink as price feed
            chainlink_usage = self._check_chainlink_feeds(checksum_addr)
            results['price_feeds'].extend(chainlink_usage.get('feeds', []))
            results['oracle_sources'].extend(chainlink_usage.get('sources', []))
            
            logger.info(f"Protocol usage detection found {len(results['oracle_sources'])} oracle sources "
                       f"and {len(results['protocol_usage'])} protocol usages")
            
            return results
            
        except Exception as e:
            logger.error(f"Error detecting protocol asset usage: {e}")
            return results
    
    def _check_compound_usage(self, target_address: str) -> Dict[str, List[str]]:
        """Check if token is used in Compound protocol."""
        results = {'oracles': [], 'usage': []}
        
        try:
            compound_config = self.defi_protocols['compound_v2']
            comptroller = compound_config['comptroller']
            oracle_address = compound_config['price_oracle']
            
            # Check if target is a cToken or underlying asset
            for market in compound_config['markets']:
                try:
                    # Get underlying asset of cToken
                    underlying_result = self.web3.eth.call({
                        'to': market,
                        'data': '0x6f307dc3'  # underlying()
                    })
                    
                    if len(underlying_result) >= 32:
                        underlying = Web3.to_checksum_address(underlying_result[-20:])
                        
                        if underlying.lower() == target_address.lower():
                            results['oracles'].append(f"compound_v2_oracle:{oracle_address}")
                            results['usage'].append(f"compound_v2_market:{market}")
                            
                            # Get price from oracle
                            price_result = self.web3.eth.call({
                                'to': oracle_address,
                                'data': '0xfc57d4df' + market[2:].zfill(64)  # getUnderlyingPrice(cToken)
                            })
                            
                            if len(price_result) >= 32:
                                results['oracles'].append(f"compound_v2_price_feed:{oracle_address}")
                                
                except Exception as e:
                    logger.debug(f"Error checking Compound market {market}: {e}")
                    continue
            
            return results
            
        except Exception as e:
            logger.debug(f"Error checking Compound usage: {e}")
            return results
    
    def _check_aave_usage(self, target_address: str) -> Dict[str, List[str]]:
        """Check if token is used in Aave protocol."""
        results = {'oracles': [], 'usage': []}
        
        try:
            # Check both Aave V2 and V3
            for version in ['aave_v2', 'aave_v3']:
                aave_config = self.defi_protocols[version]
                oracle_address = aave_config['price_oracle']
                
                try:
                    # Get asset price from Aave oracle
                    # getAssetPrice(asset) selector: 0xb3596f07
                    price_result = self.web3.eth.call({
                        'to': oracle_address,
                        'data': '0xb3596f07' + target_address[2:].zfill(64)
                    })
                    
                    if len(price_result) >= 32:
                        price = int.from_bytes(price_result, byteorder='big')
                        if price > 0:  # Asset has a price feed
                            results['oracles'].append(f"{version}_oracle:{oracle_address}")
                            results['usage'].append(f"{version}_asset:{target_address}")
                            
                except Exception as e:
                    logger.debug(f"Error checking {version} usage: {e}")
                    continue
            
            return results
            
        except Exception as e:
            logger.debug(f"Error checking Aave usage: {e}")
            return results
    
    def _check_makerdao_usage(self, target_address: str) -> Dict[str, List[str]]:
        """Check if token is used in MakerDAO system."""
        results = {'oracles': [], 'usage': []}
        
        try:
            maker_config = self.defi_protocols['makerdao']
            spot_address = maker_config['spot']
            
            # Check known price feeds for common tokens
            for feed_address in maker_config['price_feeds']:
                try:
                    # This is simplified - real implementation would check ilk registry
                    # For now, we'll mark as potential oracle source
                    results['oracles'].append(f"makerdao_feed:{feed_address}")
                    
                except Exception as e:
                    logger.debug(f"Error checking MakerDAO feed {feed_address}: {e}")
                    continue
            
            return results
            
        except Exception as e:
            logger.debug(f"Error checking MakerDAO usage: {e}")
            return results
    
    def _check_chainlink_feeds(self, target_address: str) -> Dict[str, List[str]]:
        """Check if token has Chainlink price feeds."""
        results = {'feeds': [], 'sources': []}
        
        try:
            chainlink_config = self.defi_protocols['chainlink']
            
            # Check known aggregators
            for pair_name, aggregator in chainlink_config['aggregators'].items():
                try:
                    # Get aggregator description to see if it matches our token
                    desc_result = self.web3.eth.call({
                        'to': aggregator,
                        'data': '0x7284e416'  # description()
                    })
                    
                    if len(desc_result) > 0:
                        # This is simplified - would need proper ABI decoding
                        results['feeds'].append(f"chainlink_feed:{aggregator}")
                        results['sources'].append(f"chainlink:{aggregator}")
                        
                except Exception as e:
                    logger.debug(f"Error checking Chainlink feed {pair_name}: {e}")
                    continue
            
            return results
            
        except Exception as e:
            logger.debug(f"Error checking Chainlink feeds: {e}")
            return results
    
    def _analyze_cross_protocol_dependencies(self, target_address: str) -> Dict[str, List[str]]:
        """Analyze cross-protocol oracle dependencies."""
        results = {'sources': []}
        
        try:
            # Check if target address itself implements oracle interfaces
            oracle_interfaces = self._detect_oracle_interfaces(target_address)
            results['sources'].extend(oracle_interfaces)
            
            # Check for oracle aggregator patterns
            aggregator_patterns = self._detect_aggregator_patterns(target_address)
            results['sources'].extend(aggregator_patterns)
            
            return results
            
        except Exception as e:
            logger.debug(f"Error analyzing cross-protocol dependencies: {e}")
            return results
    
    def _detect_oracle_interfaces(self, contract_address: str) -> List[str]:
        """Detect if contract implements oracle interfaces."""
        interfaces = []
        
        try:
            # Test common oracle function selectors
            test_selectors = [
                ('0x50d25bcd', 'chainlink_aggregator'),  # latestAnswer()
                ('0xfeaf968c', 'chainlink_aggregator'),  # latestRoundData()
                ('0x98d5fdca', 'custom_oracle'),        # getPrice()
                ('0xa035b1fe', 'custom_oracle')         # price()
            ]
            
            for selector, interface_type in test_selectors:
                try:
                    result = self.web3.eth.call({
                        'to': contract_address,
                        'data': selector
                    })
                    
                    if len(result) > 0:
                        interfaces.append(f"{interface_type}:{contract_address}")
                        
                except Exception:
                    continue
            
            return interfaces
            
        except Exception as e:
            logger.debug(f"Error detecting oracle interfaces: {e}")
            return []
    
    def _detect_aggregator_patterns(self, contract_address: str) -> List[str]:
        """Detect oracle aggregator patterns."""
        patterns = []
        
        try:
            # Check bytecode for oracle-related patterns
            bytecode = self.web3.eth.get_code(contract_address)
            if not bytecode:
                return patterns
            
            bytecode_hex = bytecode.hex().lower()
            
            # Look for Chainlink aggregator proxy patterns
            chainlink_patterns = [
                '50d25bcd',  # latestAnswer selector
                'feaf968c',  # latestRoundData selector
            ]
            
            for pattern in chainlink_patterns:
                if pattern in bytecode_hex:
                    patterns.append(f"chainlink_proxy:{contract_address}")
                    break
            
            return patterns
            
        except Exception as e:
            logger.debug(f"Error detecting aggregator patterns: {e}")
            return []
    
    def _analyze_dex_oracle_relationships(self, session: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Analyze DEX oracle relationships from session data."""
        try:
            dex_refs = session.get('dex_refs', [])
            if not dex_refs:
                return None
            
            analysis = {
                'type': 'twap_multi_source',
                'sources': [],
                'twap_windows': [],
                'liquidity_weighted_average': 0.0
            }
            
            total_liquidity = 0.0
            for dex_ref in dex_refs:
                pair_address = dex_ref.get('pair')
                dex_name = dex_ref.get('dex_name', 'unknown')
                liquidity_usd = dex_ref.get('liquidity_usd', 0)
                
                if pair_address:
                    analysis['sources'].append(f"dex_pair:{pair_address}")
                    
                    # Estimate TWAP window based on DEX type
                    estimated_window = self._estimate_dex_twap_window(dex_name, liquidity_usd)
                    if estimated_window:
                        analysis['twap_windows'].append(estimated_window)
                    
                    total_liquidity += liquidity_usd
            
            analysis['total_liquidity'] = total_liquidity
            
            # Calculate weighted average TWAP window
            if analysis['twap_windows']:
                analysis['twap_window'] = int(sum(analysis['twap_windows']) / len(analysis['twap_windows']))
            
            return analysis if analysis['sources'] else None
            
        except Exception as e:
            logger.debug(f"Error analyzing DEX oracle relationships: {e}")
            return None
    
    def _estimate_dex_twap_window(self, dex_name: str, liquidity_usd: float) -> Optional[int]:
        """Estimate appropriate TWAP window based on DEX and liquidity."""
        try:
            # Base windows by DEX type
            base_windows = {
                'uniswap_v2': 1800,    # 30 minutes
                'uniswap_v3': 900,     # 15 minutes  
                'sushiswap': 1800,     # 30 minutes
                'curve': 3600,         # 1 hour (more stable)
                'balancer': 2400       # 40 minutes
            }
            
            base_window = base_windows.get(dex_name, 1800)
            
            # Adjust based on liquidity (higher liquidity = shorter safe window)
            if liquidity_usd > 10000000:  # > $10M
                return max(300, base_window // 2)  # Can use shorter window
            elif liquidity_usd > 1000000:  # > $1M
                return base_window
            elif liquidity_usd > 100000:   # > $100k
                return base_window * 2
            else:
                return base_window * 4  # Very conservative for low liquidity
                
        except Exception:
            return 1800  # Default 30 minutes
    
    def _calculate_enhanced_risk_score(self, oracle_info: OracleInfo, session: Dict[str, Any]) -> float:
        """Calculate enhanced oracle risk score with multi-protocol factors."""
        try:
            risk_factors = {}
            
            # Factor 1: Source diversity (enhanced)
            source_count = len(oracle_info.sources)
            protocol_diversity = len(set(src.split(':')[0] for src in oracle_info.sources))
            
            if source_count == 0:
                risk_factors['source_diversity'] = 1.0
            elif source_count == 1:
                risk_factors['source_diversity'] = 0.9
            elif protocol_diversity == 1:  # Multiple sources, same protocol
                risk_factors['source_diversity'] = 0.7
            elif protocol_diversity >= 3:  # Multiple protocols
                risk_factors['source_diversity'] = 0.2
            else:
                risk_factors['source_diversity'] = 0.5
            
            # Factor 2: TWAP window risk
            if oracle_info.twap_window:
                if oracle_info.twap_window < 300:      # < 5 min
                    risk_factors['twap_window'] = 0.9
                elif oracle_info.twap_window < 900:    # < 15 min
                    risk_factors['twap_window'] = 0.7
                elif oracle_info.twap_window < 1800:   # < 30 min
                    risk_factors['twap_window'] = 0.5
                else:
                    risk_factors['twap_window'] = 0.2
            else:
                risk_factors['twap_window'] = 0.6
            
            # Factor 3: Protocol maturity and reliability
            protocol_risk = self._assess_protocol_reliability(oracle_info.sources)
            risk_factors['protocol_reliability'] = protocol_risk
            
            # Factor 4: Liquidity concentration risk
            dex_refs = session.get('dex_refs', [])
            liquidity_risk = self._assess_liquidity_concentration_risk(dex_refs)
            risk_factors['liquidity_concentration'] = liquidity_risk
            
            # Factor 5: Oracle type specific risks
            oracle_type_risk = self._assess_oracle_type_risk(oracle_info.type)
            risk_factors['oracle_type'] = oracle_type_risk
            
            # Weight factors for comprehensive scoring
            weights = {
                'source_diversity': 0.25,
                'twap_window': 0.20,
                'protocol_reliability': 0.20,
                'liquidity_concentration': 0.20,
                'oracle_type': 0.15
            }
            
            risk_score = calculate_risk_score(risk_factors, weights)
            return min(1.0, risk_score)
            
        except Exception as e:
            logger.debug(f"Error calculating enhanced risk score: {e}")
            return 0.5
    
    def _assess_protocol_reliability(self, sources: List[str]) -> float:
        """Assess reliability based on protocols used."""
        if not sources:
            return 1.0
        
        # Protocol reliability scores (lower = better)
        protocol_scores = {
            'chainlink': 0.1,        # Highest reliability
            'compound_v2': 0.2,      # Battle-tested
            'aave_v2': 0.2,          # Battle-tested
            'aave_v3': 0.25,         # Newer but solid
            'makerdao': 0.15,        # Very reliable
            'dex_pair': 0.6,         # Medium reliability
            'custom_oracle': 0.8,    # Higher risk
            'unknown': 0.9           # Unknown = risky
        }
        
        total_score = 0.0
        for source in sources:
            protocol = source.split(':')[0]
            score = protocol_scores.get(protocol, 0.9)
            total_score += score
        
        return total_score / len(sources)
    
    def _assess_liquidity_concentration_risk(self, dex_refs: List[Dict[str, Any]]) -> float:
        """Assess risk from liquidity concentration."""
        if not dex_refs:
            return 0.5
        
        try:
            total_liquidity = sum(ref.get('liquidity_usd', 0) for ref in dex_refs)
            if total_liquidity == 0:
                return 0.8
            
            # Calculate Herfindahl-Hirschman Index for concentration
            hhi = sum((ref.get('liquidity_usd', 0) / total_liquidity) ** 2 for ref in dex_refs)
            
            # Convert HHI to risk score
            if hhi > 0.8:      # Highly concentrated
                return 0.8
            elif hhi > 0.5:    # Moderately concentrated  
                return 0.5
            else:              # Well distributed
                return 0.2
                
        except Exception:
            return 0.5
    
    def _assess_oracle_type_risk(self, oracle_type: str) -> float:
        """Assess risk based on oracle type."""
        type_risks = {
            'chainlink': 0.1,
            'twap_multi_source': 0.3,
            'twap': 0.6,
            'custom': 0.8,
            'unknown': 0.9
        }
        
        return type_risks.get(oracle_type, 0.9)
