# shadowscan/commands/screen.py
import asyncio
import sys
import json
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any

import click
from rich.console import Console
from rich.panel import Panel

from shadowscan.core.professional_engine import ProfessionalPenetrationEngine
from shadowscan.core.hypothesis_storage import HypothesisStorage
from dataclasses import asdict
from ..utils.display_helpers import display_screening_summary, save_screening_results

console = Console()

@click.command()
@click.option("--target", "-t", required=True,
              help="Target contract address")
@click.option("--chain", "-c", default="ethereum",
              type=click.Choice(['ethereum', 'polygon', 'arbitrum', 'optimism', 'bsc']),
              help="Blockchain network")
@click.option("--depth", type=click.Choice(['basic', 'full']), default='full',
              help="Screening depth level")
@click.option("--dex-intel", is_flag=True,
              help="Include DEX intelligence gathering")
@click.option("--output", "-o",
              help="Output file for screening results")
@click.option("--format", "-f", type=click.Choice(['json', 'html']), default='json',
              help="Output format")
def screen(target: str, chain: str, depth: str, dex_intel: bool,
           output: Optional[str], format: str):
    """Execute comprehensive vulnerability screening"""
    global current_engine

    console.print(Panel.fit(
        f"[bold]Target:[/bold] {target}\n"
        f"[bold]Chain:[/bold] {chain.upper()}\n"
        f"[bold]Depth:[/bold] {depth.upper()}\n"
        f"[bold]DEX Intel:[/bold] {'ENABLED' if dex_intel else 'DISABLED'}",
        title="[bold cyan]Professional Screening Configuration[/bold cyan]"
    ))

    try:
        # Initialize professional engine
        current_engine = ProfessionalPenetrationEngine(
            target=target,
            scan_type="blockchain",
            chain=chain
        )

        # Execute screening
        results = asyncio.run(current_engine.screen_only_mode())

        # Display results summary
        display_screening_summary(results)

        # Auto-store screening results as hypotheses
        hypothesis_ids = []
        if results.get("all_findings"):
            storage = HypothesisStorage()

            # Get current block from provider
            block_number = 0
            try:
                health = asyncio.run(current_engine.provider.health_check())
                block_number = health.get("latest_block", 0)
            except:
                pass

            hypothesis_ids = storage.store_screening_session(
                target=target,
                chain=chain,
                findings=results["all_findings"],
                block_number=block_number
            )

            console.print(f"\n[bold green]Stored {len(hypothesis_ids)} hypotheses in findings database[/bold green]")
            for hyp_id in hypothesis_ids:
                console.print(f"  {hyp_id}")

        # Save results if requested
        if output:
            save_screening_results(results, output, format)
            console.print(f"\n[bold green]‚úÖ Screening results saved:[/bold green] {output}")

        # Display next steps
        high_exploitability = [
            f for f in results.get("all_findings", [])
            if f.get("exploitability_score", 0) > 0.7
        ]

        if hypothesis_ids:
            console.print(f"\n[bold yellow]üéØ Next Steps:[/bold yellow]")
            console.print("View all findings: shadowscan findings")
            console.print(f"Filter by target: shadowscan findings --target {target}")

            if high_exploitability:
                console.print("Verify high-priority hypotheses:")
                high_priority_hyp_ids = hypothesis_ids[:len(high_exploitability)]
                for hyp_id in high_priority_hyp_ids[:3]:
                    console.print(f"  shadowscan verify --hyp {hyp_id} --sim tenderly")

    except Exception as e:
        console.print(f"[bold red]‚ùå Screening failed:[/bold red] {str(e)}")
        sys.exit(1)
